#!/usr/bin/env ruby

require 'fileutils'
require 'webkit-gtk'
require 'net/http'
require 'nokogiri'
require 'sqlite3'

class Db
	def initialize path
		begin
			@db = SQLite3::Database.open path
		rescue
			puts 		"can't open database"
			exit
		end

		@db.execute 	"CREATE TABLE IF NOT EXISTS bookmark" \
					"(id INTEGER PRIMARY KEY" \
					",name text" \
					",url text" \
					",comment text" \
					",tag text" \
					",UNIQUE(url))"
	end

	def insert data
		stm 		= @db.prepare "INSERT INTO bookmark " \
					"(name, url, comment, tag) VALUES(?,?,?,?)"
	
		stm.bind_param 	1, data[0]
		stm.bind_param 	2, data[1]
		stm.bind_param 	3, data[2]
		stm.bind_param 	4, data[3]

		begin
			rs 		= stm.execute
			return (find "url", data[1])
		rescue
			Actions.error "url already exists", false
		end
	end

	def import data
		stm 		= @db.prepare "INSERT OR IGNORE INTO bookmark " \
					"(name, url, comment, tag) VALUES(?,?,?,?)"
	
		stm.bind_param 	1, data[0]
		stm.bind_param 	2, data[1]
		stm.bind_param 	3, data[2]
		stm.bind_param 	4, data[3]
	end

	def delete id
		stm 		= @db.prepare "DELETE FROM bookmark " \
					"WHERE id = ?"	

		stm.bind_param	1, id
		rs 		= stm.execute
	end

	def delete_tag tag
		stm 		= @db.prepare "DELETE FROM bookmark " \
					"WHERE tag = ?"

		stm.bind_param 	1, tag
		rs 		= stm.execute
	end

	def edit id, field, value
		if field == "name" \
		or field == "url" \
		or field == "comment" \
		or field == "tag"
			stm 		= @db.prepare "UPDATE bookmark " \
						"SET #{field} = ? WHERE id = ?"

			stm.bind_param 	1, value
			stm.bind_param 	2, id
			rs 		= stm.execute
		end
	end

	def edit_tag tag, new_tag
		stm 		= @db.prepare "UPDATE bookmark " \
					"SET tag = ? WHERE tag = ?"

		stm.bind_param 	1, new_tag
		stm.bind_param 	2, tag
		rs 		= stm.execute
	end

	def find field, value
		if field == "name" \
		or field == "url" \
		or field == "comment" \
		or field == "tag"
			stm 		= @db.prepare "SELECT * FROM bookmark " \
						"WHERE #{field} = ? ORDER BY tag ASC"

			stm.bind_param 	1, value
			rs		= stm.execute
		end
	end

	def fetch filter
		if filter
			stm 	= @db.prepare "SELECT * FROM bookmark " \
					"WHERE name LIKE '%%#{filter}%%' " \
					"OR url LIKE '%%#{filter}%%' " \
					"OR comment LIKE '%%#{filter}%%' " \
					"OR tag LIKE '%%#{filter}%%' " \
					"ORDER BY tag ASC"
		else
			stm 	= @db.prepare "SELECT * from bookmark " \
					"ORDER BY tag ASC"
		end

		rs 		= stm.execute
	end
end

class Settings
	def initialize
		@s = Hash[ \
			"dir" 			=> "#{ENV['HOME']}/.config/" \
							"pmb" \
			,"config" 		=> "config" \
			,"db" 			=> "#{ENV['HOME']}/.config/" \
							"pmb/bookmarks.db" \
			,"id_fg" 		=> String.new \
			,"id_font" 		=> String.new \
			,"url_fg" 		=> String.new \
			,"url_font" 		=> String.new \
			,"comment_fg" 		=> String.new \
			,"comment_font"		=> String.new \
			,"tag_fg" 		=> String.new \
			,"tag_font" 		=> String.new \
			,"url_underline"	=> "true" \
			,"style"		=> "0" \
			,"show_toolbar"		=> "true" \
			,"show_filterbar"	=> "true" \
			,"xclip" 		=> "true" \
			,"tree_lines" 		=> "false" \
			,"auto_favicon" 	=> "true" \
			,"enable_javascript"	=> "false" \
			,"open_command"		=> "firefox -new-tab -url" \
			,"user_agent"		=> "Mozilla/5.0 (X11; Linux i686; rv:45.0) Gecko/20100101 Firefox/45.0"]

		if !(File.exists? "#{@s['dir']}")
			Dir.mkdir "#{@s['dir']}"
		end

		if !(File.exists? "#{@s['dir']}/favicon")
			Dir.mkdir "#{@s['dir']}/favicon"
		end

		if !(File.exists? "#{@s['dir']}/#{@s['config']}")
			save_config
		else
			load_config
		end
	end

	def save_config
		File.open("#{@s['dir']}/#{@s['config']}", "w") do |f|
			f.write "#DO NOT EDIT BY HAND\n\n"

			@s.each do |i|
				f.write "#{i[0]} = #{i[1]}\n"
			end
		end
	end

	def load_config
		File.open("#{@s['dir']}/#{@s['config']}", "r") do |f|
			while l = f.gets do
				if @s[l[/(^.*?\s)/][0...-1]]
					@s[l[/(^.*?\s)/][0...-1]] = l[/(?<==\s).*/]
				end
			end
		end
	end

	attr_accessor :s
end

class Web_Data
	def self.favicon_exist? url, s
		uri  	= URI url
		path 	= "#{s['dir']}/favicon/#{uri.host}#{uri.path}"

		if (File.exists? "#{path}/icon")
			return true
		end

		nil
	end

	def self.favicon_fetch uri, path, file
		begin 
			http 	= Net::HTTP.start uri.host \
					,:read_timeout 	=> 0.500 \
					,:use_https 	=> uri.scheme == 'https'

			icon 	= http.get file

			if icon.message == "Redirect" \
			or icon.message == "Moved Permanently" \
			or icon.message == "Moved Temporarily" 
				icon = (Net::HTTP.get (URI icon['location']))

				if !is_image? icon
					icon = (Net::HTTP.get (URI file))
				end

				if !is_image? icon
					icon = (Net::HTTP.get \
						(URI "#{uri.scheme}://#{uri.host}/favicon.ico"))
				end

				favicon_write path, icon
			elsif icon.message == "Not Found"
				nil
			else
				favicon_write path, icon.body
			end
		rescue Exception => e #ugly, anyway ..
			nil
		end
	end

	def self.webkit_favicon_fetch url, store, tree, s
		uri  		= URI url
		path 		= "#{s['dir']}/favicon/#{uri.host}#{uri.path}"
		view 		= WebKitGtk::WebView.new

		if s['enable_javascript'] == "true"
			view.settings.enable_scripts 			= true
		else
			view.settings.enable_scripts 			= false
		end

		view.settings.enable_plugins 				= false
		view.settings.auto_shrink_images 			= true
		view.settings.enable_offline_web_application_cache 	= false
		view.settings.enable_display_of_insecure_content 	= false
		view.settings.enable_running_of_insecure_content 	= false
		view.settings.enable_dom_paste 				= false
		view.settings.enable_java_applet 			= false
		view.settings.enable_page_cache 			= false
		view.settings.enable_html5_database 			= false
		view.settings.enable_html5_local_storage 		= false
		view.settings.enable_media_stream 			= false
		view.settings.enable_webgl 				= false
		view.settings.enable_webaudio 				= false
		view.settings.enable_mediasource 			= false
		view.settings.user_agent 				= s['user_agent']	

		view.load_uri	url

		view.signal_connect "icon-loaded" do
			if (f = view.try_get_favicon_pixbuf 20, 20)
				if !(File.exists? path)
					FileUtils.mkdir_p path
				end

				f.save "#{path}/icon", "png", nil

				tree.model.each do |model, tpath, iter|
					if (store.get_value iter, 3) == url
						store.set_value iter, 2, f 
					end
				end

				view 		= nil
			else
				favicon_fetch uri, path, view.icon_uri

				tree.model.each do |model, tpath, iter|
					if (store.get_value iter, 3) == url \
					and (File.exist? "#{path}/icon")
						store.set_value iter, 2, (Gdk::Pixbuf.new \
							"#{path}/icon", 20, 20)
					end
				end		

				view 		= nil
			end
		end
	end

	def self.is_svg? icon
		doc 		= Nokogiri icon
		svg	 	= doc.css "svg"

		for i in svg do
			if i['version'] == "1.1" \
			and i['xmlns'] == "http://www.w3.org/2000/svg"
				return true
			end
		end

		nil
	end

	def self.is_image? icon
		png 	= Regexp.new("\x89PNG".force_encoding("binary"))
		jpg 	= Regexp.new("\xff\xd8\xff\xe0\x00\x10JFIF".force_encoding("binary"))
		jpg2	= Regexp.new("\xff\xd8\xff\xe1(.*){2}Exif".force_encoding("binary"))

		if icon[0,4] == "\x00\x00\x01\x00" \
		or icon[0,2] == "\x42\x4d" \
		or icon[/^#{png}/] \
		or icon[/^#{jpg}/] \
		or icon[/^#{jpg2}/]
			return true
		end

		nil
	end

	def self.favicon_write path, icon
		if is_image? icon
			if !(File.exists? path)
				FileUtils.mkdir_p path
			end

			File.open("#{path}/icon", "wb") do |f|
				f.write icon
			end
		end
	end
end

class Actions
	def self.clipboard store, tree, s
		iter	= tree.model.get_iter tree.selection.selected_rows[0]
		url 	= store.get_value iter, 3

		if !url.empty?
			if s['xclip'] == "true"
				Process.detach spawn \
					"echo -n '#{url}' | xclip -i -selection 'primary'"

				Process.detach spawn \
					"echo -n '#{url}' | xclip -i -selection 'secoundary'"

				Process.detach spawn \
					"echo -n '#{url}' | xclip -i -selection 'clipboard'"
			else
				clip_p 		= Gtk::Clipboard.get Gdk::Selection::PRIMARY
				clip_c 		= Gtk::Clipboard.get Gdk::Selection::CLIPBOARD

				clip_p.text 	= url
				clip_c.text 	= url

				clip_p.store
				clip_c.store
			end
		end
	end

	def self.store_feed db, store, tree
		store.clear
		
		if store.style.to_i == 0
			store.feed_tree		(db.fetch store.filter)
		else
			store.feed_tag		(db.fetch store.filter)
		end

		tree.expand_all

		if tree.selected_row \
		and (tree.model.get_iter tree.selected_row)
			tree.set_cursor 	tree.selected_row, nil, false
		end
	end

	def self.open store, tree, settings, window
		chooser = Gtk::FileChooserDialog.new \
			:title 		=> "Open" \
			,:parent 	=> window \
			,:action 	=> :save \
			,:buttons 	=> [ \
				[Gtk::Stock::CANCEL, :cancel] \
				,[Gtk::Stock::OPEN, :accept]]

		db 	= nil

		if chooser.run == Gtk::ResponseType::ACCEPT
			begin
				db 			= Db.new chooser.filename
				settings.s['db'] 	= chooser.filename
				store.tag_list		= Array.new
				chooser.destroy

				Actions.store_feed 	db, store, tree
				settings.save_config
			rescue
				chooser.destroy
				Actions.error 		"Error opening file", false
			end
		else
			chooser.destroy
		end

		if db
			db
		end
	end

	def self.import db_ex, window
		chooser = Gtk::FileChooserDialog.new \
			:title 		=> "Open" \
			,:parent 	=> window \
			,:action 	=> :open \
			,:buttons 	=> [ \
				[Gtk::Stock::CANCEL, :cancel] \
				,[Gtk::Stock::OPEN, :accept]]

		if chooser.run == Gtk::ResponseType::ACCEPT
			begin
				db 	= Db.new chooser.filename
				r 	= db.fetch nil

				for i in r do
					db_ex.import [i[1], i[2], i[3], i[4]]
				end

				chooser.destroy
			rescue
				chooser.destroy
				Actions.error 	"Error importing file", false
			end
		else
			chooser.destroy
		end
	end

	def self.insert db, store, tree, s
		Gtk_Insert.new 		db, store, tree, s
	end

	def self.edit db, store, tree, s
		if tree.model.iter_first
			tree.selected_row 	= tree.selection.selected_rows[0]
			Gtk_Edit.new 		db, store, tree, s
		else
			error "Nothing to edit.", false
		end
	end

	def self.delete db, store, tree, s
		if tree.model.iter_first 
			tree.selected_row 	= tree.selection.selected_rows[0]
			Gtk_Delete.new 		db, store, tree, s
		else
			error "Nothing to delete.", false
		end
	end

	def self.settings settings, db, store, tree
		tree.selected_row 	= tree.selection.selected_rows[0]
		Gtk_Settings.new 	settings, db, store, tree
	end

	def self.error message, fatal
		Gtk_Error.new 		message, fatal
	end

	def self.open_bookmark store, tree, s
		if !tree.selection.selected_rows.empty?
			tree.selection.selected_rows.each do |row|
				iter 	= tree.model.get_iter row
				url 	= store.get_value iter, 3
		
				if !url.empty?
					open_url store, iter, s
				end

				if url.empty? and iter.has_child?
					open_tag store, tree, iter.first_child, s
				end
			end
		end
	end

	def self.open_url store, iter, s
		url 	= store.get_value iter, 3

		if !url.empty?
			Process.detach spawn "#{s['open_command']} #{url}"
		end
	end

	def self.open_tag store, tree, iter, s
		if iter.has_child?
			open_tag 	store, tree, iter.first_child, s
		else
			open_url 	store, iter, s
		end

		while iter.next!
			if iter.has_child?
				open_tag 	store, tree, iter.first_child, s
			else
				open_url	store, iter, s
			end
		end
	end		
		
	def self.download_favicon store, tree, s
		if !tree.selection.selected_rows.empty?
			iter	= tree.model.get_iter tree.selection.selected_rows[0]
			url 	= store.get_value iter, 3

			Web_Data.webkit_favicon_fetch url, store, tree, s
		end
	end

	def self.search_icon icon
		icon_theme 	= Gtk::IconTheme.default

		if icon_theme.has_icon? icon
			r = icon_theme.load_icon icon \
				,16, Gtk::IconTheme::LookupFlags::FORCE_SIZE
			return r
		end

		nil
	end

	def self.search_icon_with_size icon, size
		icon_theme 	= Gtk::IconTheme.default

		if icon_theme.has_icon? icon
			r = icon_theme.load_icon icon \
				,size, Gtk::IconTheme::LookupFlags::FORCE_SIZE
			return r
		end

		nil
	end

	def self.set_icon url, alt, s
		if url and url[/^(http|https)/]
			if (Web_Data.favicon_exist? url, s)
				begin
					uri  	= URI url
					path 	= "#{s['dir']}/favicon/#{uri.host}#{uri.path}"
					icon 	= Gdk::Pixbuf.new "#{path}/icon", 20, 20
				rescue
					icon = Actions.search_icon alt
				end
			else
				icon = Actions.search_icon alt
			end
		
			return icon
		else
			return (Actions.search_icon alt)
		end
	end
end

class Store < Gtk::TreeStore
	attr_accessor :filter, :style, :tag_list

	def initialize *args
		super(*args[1..-1])
		@s		= args[0]
		@style 		= @s['style'].to_i
		@tag_list	= Array.new
	end

	def search_toplevel entry
		each do |st, tp, it|
			if it \
			and entry \
			and entry == (get_value it, 4) \
			and !it.parent
				return it
			end
		end

		false
	end

	def search_children entry, parent
		each do |st, tp, it|
			if it \
			and entry \
			and entry == (get_value it, 4) \
			and it.parent \
			and parent == (get_value it.parent, 4) 
				return it
			end
		end

		false
	end

	def get_iter_root iter
		parent = iter.parent
		
		if !parent
			return iter
		end

		if parent and parent.parent
			get_iter_root parent
		elsif parent and !parent.parent
			return parent
		end
	end

	def n_entries child, n
		if child and !child.has_child?
			child.next!
			n_entries child, n + 1
		else
			return n
		end
	end

	def insert_dir iter, name, tag, number_of_items
		it = insert iter, number_of_items += 1 \
			,["", (Actions.search_icon "folder"), nil, "", "#{name}", "", "#{tag}"]

		it
	end

	def insert_item iter, item, number_of_items
		insert iter, number_of_items \
			,["#{item[0]}" \
			,(Actions.search_icon "web-browser-symbolic") \
			,(Actions.set_icon item[2], "starred-symbolic", @s) \
			,"#{item[2]}" \
			,"#{item[1]}" \
			,"#{item[3]}" \
			,"#{item[4]}"]

		number_of_items += 1
	end

	def tag dirs, item, number_of_items
		iter = nil
		root = nil

		dirs.each_with_index do |d, j|
			if j == 0
				if !(iter = search_toplevel d)
					iter = insert_dir nil, d, item[4] \
						,number_of_items
				end		

				root = iter
			else
				if dirs[j - 1] 
					if !(r = search_children d, dirs[j - 1]) 
						if dirs[j]
							iter = insert_dir iter, d, item[4] \
								,number_of_items
						end
					else
						if !root == (get_iter_root r)
							iter = insert_dir iter, d, item[4] \
								,number_of_items
						else
							iter = r
						end
					end
				end
			end
		end
	
		@tag_list[@tag_list.size] = get_value iter, 6
		iter
	end

	def feed_tree result
		number_of_items = 0

		for i in result do
			iter 		= tag (i[4].split '/'), i, number_of_items
			number_of_items = insert_item iter, i, number_of_items
			icon 		= nil
		end

		@tag_list.uniq!
	end

	def feed_tag result
		last 			= nil
		number_of_items 	= 0

		for i in result do
			if !last or i[4] != last
				iter 	= insert_dir nil, i[4], i[4], number_of_items
			end

			number_of_items = insert_item iter, i, number_of_items
		end

		@tag_list.uniq!
	end

	def append_item items
		for i in items do
			iter 		= tag (i[4].split '/'), i, 0
			insert_item 	iter, i, (n_entries iter.first_child, 0)
			icon 		= nil
		end

		@tag_list.uniq!
		@tag_list.sort!
	end

	def delete_tag tag
		@tag_list.each_with_index do |t, i|
			if tag == t
				@tag_list.delete_at i
			end
		end
	end

	def delete_parent parent
		if parent and !parent.has_child?
			tag		= get_value parent, 6
			delete_tag 	tag
			remove 		parent
		end
	end

	def values iter
		id 		= get_value iter, 0
		name 		= get_value iter, 4
		url  		= get_value iter, 3
		comment 	= get_value iter, 5
		tag 		= get_value iter, 6

		[id, name, url, comment, tag]
	end
end

class Tree < Gtk::TreeView
	def initialize store
		super store
		@render_id 		= Gtk::CellRendererText.new
		@render_name		= Gtk::CellRendererText.new
		@render_url 		= Gtk::CellRendererText.new
		@render_comment		= Gtk::CellRendererText.new
		@render_tag 		= Gtk::CellRendererText.new
		@selected_row 		= nil
	end

	def parse_color render, color_fg
		if !color_fg.empty?
			render.foreground_gdk 	= Gdk::Color.parse color_fg
		else
			render.foreground 	= nil
		end
	end

	def parse_font render, font
		if !font.empty?
			render.font 	= font
		else
			render.font 	= nil
		end
	end

	def load_settings s
		parse_color 	@render_id, s['id_fg']
		parse_color 	@render_url, s['url_fg']
		parse_color 	@render_comment, s['comment_fg']
		parse_color 	@render_tag, s['tag_fg']

		parse_font 	@render_id, s['id_font']
		parse_font 	@render_url, s['url_font']
		parse_font 	@render_comment, s['comment_font']
		parse_font 	@render_tag, s['tag_font']

		if s['url_underline'] == "true"
			@render_url.underline = "single"
		else
			@render_url.underline = "none"
		end

		if s['tree_lines'] == "true"
			self.enable_tree_lines  = true
		else
			self.enable_tree_lines  = false
		end

		columns_autosize
		self.search_column	= s['search_column'].to_i
	end

	attr_reader \
		:render_id \
		,:render_name \
		,:render_url \
		,:render_comment \
		,:render_tag 

	attr_accessor :tree_lines, :selected_row
end

class Grid < Gtk::Grid
	def initialize
		super
		set_property 	"row-homogeneous"	,true
		set_property 	"column-homogeneous"	,true
	end
end

class Gtk_Window < Gtk::Window
	def initialize 
		super
		set_wmclass 	"Poor man's bookmark"	,"Pmb"
		set_title 	"Poor man's bookmark"
		set_type_hint 	:dialog
		set_default_size 600, 0

		signal_connect "destroy" do
			destroy
		end
	end

	def create_name_entry text
		name_entry 		= Gtk::Entry.new

		if (icon = Actions.search_icon "insert-text-symbolic")
			name_entry.primary_icon_pixbuf = icon
			name_entry.primary_icon_activatable = false
		end

		if text
			name_entry.set_text text
		end

		name_entry
	end

	def create_url_entry text, favicon, s, tree, store
		url_entry 		= Gtk::Entry.new

		url_entry.primary_icon_pixbuf = favicon

		if text
			url_entry.set_text text
		end

		url_entry.signal_connect "icon-press" do
			if url_entry.text and url_entry.text[/(http|https)/]
				Actions.download_favicon store, tree, s
			end
		end

		url_entry.primary_icon_activatable = true
		url_entry
	end

	def create_comment_entry text
		comment_entry 		= Gtk::Entry.new

		if (icon = Actions.search_icon "insert-text-symbolic")
			comment_entry.primary_icon_pixbuf = icon
			comment_entry.primary_icon_activatable = false
		end

		if text
			comment_entry.set_text text
		end

		comment_entry
	end

	def create_tag_entry text
		tag_entry 		= Gtk::Entry.new

		if (icon = Actions.search_icon "insert-text-symbolic")
			tag_entry.primary_icon_pixbuf = icon
			tag_entry.primary_icon_activatable = :off
		end

		if text
			tag_entry.set_text text
		end

		tag_entry
	end

	def create_tag_list tag_list, entry, item_active
		tag_combo		= Gtk::ComboBoxText.new

		tag_list.each_with_index do |tag, i|
			tag_combo.insert_text 	(i + 1), tag
		end

		if item_active
			tag_combo.model.each do |model, path, iter|
				if (model.get_value iter, 0) == item_active
					tag_combo.set_active_iter iter
				end
			end
		else
			tag_combo.set_active 	0
		end

		tag_combo.signal_connect "changed" do |t|
			entry.text 		= t.active_text
		end

		tag_combo
	end

	def selected_rows_grid store, tree, rows, s
		grid		= Grid.new

		rows.each_with_index do |row, i|
			values			= store.values (tree.model.get_iter row)
			name_entry 		= create_name_entry values[1]
			name_entry.set_editable false

			url_entry 		= create_url_entry values[2] \
							,(Actions.set_icon values[2] \
							,"starred-symbolic", s), s, tree, store
			url_entry.set_editable 	false
			url_entry.primary_icon_activatable = false

			grid.attach name_entry,		0,  i,  20,   1
			grid.attach url_entry,		20, i,  20,   1
		end

		grid
	end

	def favicon store, tree, url, s
		tree.model.each do |model, tpath, iter|
			if (store.get_value iter, 3) == url
				tree.set_cursor tpath, nil, false

				if s['auto_favicon'] == "true" \
				and !(Web_Data.favicon_exist? url, s)
					Actions.download_favicon store, tree, s
				end
			end
		end		
	end
end

class Gtk_Error < Gtk_Window
	def initialize message, fatal
		super()
		set_title 		title + " - Error"

		error_label 		= Gtk::Label.new 
		error_label.set_markup	"<span foreground='red' " \
						"font-weight='heavy' " \
						"size='large'>" \
						"Error \n" \
						"</span>"

		error 			= Gtk::Label.new message
		close_button 		= Gtk::Button.new :stock_id => Gtk::Stock::CLOSE

		close_button.signal_connect "clicked" do
			if fatal
				Gtk.main_quit
			else
				destroy
			end
		end

		grid 				= Grid.new

						#e   #t   #l    #a
		grid.attach error_label, 	0,   0,   20,   1
		grid.attach error, 		0,   1,   20,   1
		grid.attach close_button, 	0,   2,   20,   1

		vbox 				= Gtk::Box.new :vertical, 2
		vbox.pack_start 		grid \
							,:expand => false \
							,:fill => false \
							,:padding => 0 \

		add 				vbox
		show_all
	end
end

class Gtk_Insert < Gtk_Window
	def initialize db, store, tree, s
		super()
		set_title 		title + " - Insert"

		name_entry 		= create_name_entry nil
		url_entry 		= create_url_entry nil, (Actions.search_icon \
						"non-starred-symbolic"), s, tree, store
		comment_entry 		= create_comment_entry nil
		tag_entry 		= create_tag_entry nil
		row 			= tree.selection.selected_rows[0]

		insert_button 		= Gtk::Button.new :stock_id => Gtk::Stock::ADD
		cancel_button 		= Gtk::Button.new :stock_id => Gtk::Stock::CANCEL

		url_entry.primary_icon_activatable = false

		if tree.model.iter_first \
		and !(tag = store.get_value (tree.model.get_iter row), 6).empty?
			tag_entry.text 	= tag
			tag_list	= create_tag_list store.tag_list, tag_entry, tag
		else
			tag_list	= create_tag_list store.tag_list, tag_entry, nil
		end 

		insert_button.signal_connect "clicked" do
			if (name_entry.text).size > 0 and (url_entry.text).size > 0
				name		= name_entry.text
				url 		= url_entry.text

				if (comment_entry.text).size == 0
					comment 	= "none"
				else
					comment 	= comment_entry.text
				end

				if (tag_entry.text).size == 0
					tag 		= "none"
				else
					tag 		= tag_entry.text
				end

				item = db.insert 	[name, url, comment, tag]
				store.append_item 	item
				tree.expand_all
				favicon 		store, tree, url, s
				destroy
			else
				Actions.error "Need at least name and url", false
			end
		end

		cancel_button.signal_connect "clicked" do
			destroy
		end

		grid 			= Grid.new

								#e   #t   #l    #a
		grid.attach (Gtk::Label.new "Name"), 		0,   0,   20,   1
		grid.attach name_entry, 			20,  0,   20,   1
		grid.attach (Gtk::Label.new "Url"), 		0,   1,   20,   1
		grid.attach url_entry,				20,  1,   20,   1
		grid.attach (Gtk::Label.new "Comment"),		0,   2,   20,   1
		grid.attach comment_entry,			20,  2,   20,   1
		grid.attach (Gtk::Label.new "Tag"), 		0,   3,   20,   1
		grid.attach tag_list,				20,  3,   20,   1
		grid.attach tag_entry,				20,  4,   20,   1
		grid.attach insert_button,			0,   5,   20,   1
		grid.attach cancel_button,			20,  5,   20,   1

		vbox 			= Gtk::Box.new :vertical, 2
		vbox.pack_start 	grid \
						,:expand 	=> false \
						,:fill 		=> false \
						,:padding 	=> 0 \

		add 			vbox
		show_all
	end
end

class Gtk_Edit < Gtk_Window
	def initialize db, store, tree, s
		super()
		set_title 		title + " - Edit"

		edit_button 		= Gtk::Button.new :stock_id => Gtk::Stock::APPLY
		cancel_button 		= Gtk::Button.new :stock_id => Gtk::Stock::CANCEL
		grid 			= Grid.new
		rows			= tree.selection.selected_rows
		
		cancel_button.signal_connect "clicked" do
			destroy
		end

		if rows.size > 1
			set_title 	title + " - Edit tags"
			set_default_size 600, 200

			tag_entry 	= create_tag_entry nil
			tag_list	= create_tag_list store.tag_list, tag_entry, nil
			s_grid		= selected_rows_grid store, tree, rows, s

			vbox 		= Gtk::Box.new :vertical, 2
			hbox 		= Gtk::Box.new :horizontal, 2

			sw 		= Gtk::ScrolledWindow.new nil, nil
			sw.border_width	= 2
			sw.shadow_type	= :out
			sw.add 		s_grid 

			hbox.pack_start edit_button
			hbox.pack_start cancel_button

			grid.attach (Gtk::Label.new "Tag"),	0,   1,   20,   1
			grid.attach tag_list,			20,  1,   20,   1
			grid.attach tag_entry, 			20,  2,   20,   1

			edit_button.signal_connect "clicked" do
				iters = Array.new

				rows.each do |i|
					iters[iters.size] = tree.model.get_iter i
				end

				iters.each_with_index do |iter, i|
					parent		= iter.parent
					values		= store.values iter

					db.edit 	values[0], "tag", tag_entry.text

					item		= [[values[0], values[1], values[2], values[3]\
								, tag_entry.text]]

					if tree.model.iter_is_valid? iter
						store.remove 		iter
						store.delete_parent 	parent
						store.append_item	item
					end
				end

				destroy
			end

			vbox.pack_start	(Gtk::Label.new "Edit tags") \
					,:expand 	=> false \
					,:fill 		=> false \
					,:padding 	=> 0 \

			vbox.pack_start sw 
			vbox.pack_start grid \
					,:expand 	=> false \
					,:fill 		=> false \
					,:padding 	=> 0 \

			vbox.pack_start hbox \
					,:expand 	=> false \
					,:fill 		=> false \
					,:padding 	=> 0 \

			add 		vbox	
		else
			row		= rows[0]
			values		= store.values (tree.model.get_iter row)

			tag_entry 	= create_tag_entry values[4]
			tag_list	= create_tag_list store.tag_list, tag_entry, values[4]

			if values[2] and values[2].empty?
				set_title 		title + " - Edit tag"
				old_tag 		= values[4]
				tag_entry.set_text 	old_tag

				tag_entry.signal_connect "activate" do
					edit_tag 	db, tree, store, row, old_tag, tag_entry
				end
				
				edit_button.signal_connect "clicked" do
					edit_tag 	db, tree, store, row, old_tag, tag_entry
				end
									#e   #t   #l    #a
				grid.attach (Gtk::Label.new "Tag"),	0,   1,   20,   1
				grid.attach tag_list,			20,  1,   20,   1
				grid.attach tag_entry, 			20,  2,   20,   1
				grid.attach edit_button,		0,   3,   20,   1
				grid.attach cancel_button,		20,  3,   20,   1

			else
				name_entry 	= create_name_entry values[1]
				url_entry 	= create_url_entry values[2], (Actions.set_icon \
							values[2],"starred-symbolic", s), s, tree, store
				comment_entry 	= create_comment_entry values[3]

				edit_button.signal_connect "clicked" do
					if values[1] != name_entry.text 
						db.edit 	values[0], "name", name_entry.text
						store.set_value	(tree.model.get_iter row)\
									,4, name_entry.text
					end

					if values[2] != url_entry.text 
						db.edit 	values[0], "url", url_entry.text
						store.set_value	(tree.model.get_iter row)\
									,3, url_entry.text
					end

					if values[3] != comment_entry.text 
						db.edit 	values[0], "comment", comment_entry.text
						store.set_value	(tree.model.get_iter row)\
									,5, comment_entry.text
					end

					if values[4] != tag_entry.text
						iter		= tree.model.get_iter row
						parent		= iter.parent
						db.edit 	values[0], "tag", tag_entry.text

						item		= [ \
							[(store.get_value iter, 0)\
							,(store.get_value iter, 4)\
							,(store.get_value iter, 3)\
							,(store.get_value iter, 5)\
							,(tag_entry.text)]\
						]

						store.remove		iter
						store.delete_parent 	parent
						store.append_item	item
					end

					tree.expand_all

					if values[2] != url_entry.text 
						favicon 	store, tree, url_entry.text, s
					end

					destroy
				end

									#e   #t   #l    #a
				grid.attach (Gtk::Label.new "Name"),	0,   1,   20,   1
				grid.attach name_entry, 		20,  1,   20,   1
				grid.attach (Gtk::Label.new "Url"), 	0,   2,   20,   1
				grid.attach url_entry,			20,  2,   20,   1
				grid.attach (Gtk::Label.new "Comment"),	0,   3,   20,   1
				grid.attach comment_entry,		20,  3,   20,   1
				grid.attach (Gtk::Label.new "Tag"), 	0,   4,   20,   1
				grid.attach tag_list,			20,  4,   20,   1
				grid.attach tag_entry,			20,  5,   20,   1
				grid.attach edit_button,		0,   6,   20,   1
				grid.attach cancel_button,		20,  6,   20,   1
			end

			vbox 			= Gtk::Box.new :vertical, 2
			vbox.pack_start 	grid \
							,:expand 	=> false \
							,:fill 		=> false \
							,:padding 	=> 0 \

			add 			vbox
		end

		show_all
	end

	def edit_tag db, tree, store, row, old_tag, tag_entry
		db.edit_tag 		old_tag, tag_entry.text
		iter			= tree.model.get_iter row
		store.remove		iter
		store.append_item	(db.find "tag", tag_entry.text)
		tree.expand_all
		destroy
	end
end

class Gtk_Delete < Gtk_Window
	def initialize db, store, tree, s
		super()
		set_title 		title + " - Delete"

		delete_button 		= Gtk::Button.new :stock_id => Gtk::Stock::DELETE
		cancel_button 		= Gtk::Button.new :stock_id => Gtk::Stock::CANCEL
		grid 			= Grid.new
		rows			= tree.selection.selected_rows

		cancel_button.signal_connect "clicked" do
			destroy
		end

		if rows.size > 1
			set_title 	title + " - Delete multiple"
			set_default_size 600, 200

			vbox 		= Gtk::Box.new :vertical, 2
			hbox 		= Gtk::Box.new :horizontal, 2
			grid 		= selected_rows_grid store, tree, rows, s

			sw 		= Gtk::ScrolledWindow.new nil, nil
			sw.border_width	= 2
			sw.shadow_type	= :out
			sw.add 		grid 

			hbox.pack_start delete_button
			hbox.pack_start cancel_button
			
			delete_button.signal_connect "clicked" do
				iters = Array.new

				rows.each do |i|
					iters[iters.size] = tree.model.get_iter i
				end

				iters.each do |i|
					if tree.model.iter_is_valid? i
						parent			= i.parent
						id 			= store.get_value i, 0
						db.delete 		id
						store.remove		i
						store.delete_parent 	parent
					end
				end

				destroy
			end
			
			vbox.pack_start	(Gtk::Label.new "delete bookmarks:")
			vbox.pack_start sw 
			vbox.pack_start hbox \
					,:expand 	=> false \
					,:fill 		=> false \
					,:padding 	=> 0 \

			add 	vbox	
		else	
			row			= rows[0]
			values			= store.values (tree.model.get_iter row)
			tag_entry 		= create_tag_entry values[4]
			tag_entry.set_editable 	false

			if values[2] and values[2].empty?
				grid.attach (Gtk::Label.new "Tag"), 	0,   0,   20,   1
				grid.attach tag_entry, 			20,  0,   20,   1
				grid.attach delete_button,		0,   1,   20,   1
				grid.attach cancel_button,		20,  1,   20,   1
			else
				name_entry 		= create_name_entry values[1]
				name_entry.set_editable false

				url_entry 		= create_url_entry values[2] \
								,(Actions.set_icon values[2] \
								,"starred-symbolic", s), s, tree, store
				url_entry.set_editable 	false
				url_entry.primary_icon_activatable = false

				comment_entry 			= create_comment_entry values[3]
				comment_entry.set_editable 	false

				grid.attach (Gtk::Label.new "Name"), 	0,   0,   20,   1
				grid.attach name_entry, 		20,  0,   20,   1
				grid.attach (Gtk::Label.new "Url"), 	0,   1,   20,   1
				grid.attach url_entry,			20,  1,   20,   1
				grid.attach (Gtk::Label.new "Comment"),	0,   2,   20,   1
				grid.attach comment_entry,		20,  2,   20,   1
				grid.attach (Gtk::Label.new "Tag"), 	0,   3,   20,   1
				grid.attach tag_entry,			20,  3,   20,   1
				grid.attach delete_button,		0,   4,   20,   1
				grid.attach cancel_button,		20,  4,   20,   1
			end

			delete_button.signal_connect "clicked" do
				iter			= tree.model.get_iter row
				parent			= iter.parent

				if values[2].empty?
					db.delete_tag 	values[4]
				else
					db.delete 	values[0]
				end

				if tree.model.iter_is_valid? iter
					store.remove		iter
					store.delete_parent 	parent
				end

				destroy
			end

			vbox 			= Gtk::Box.new :vertical, 2
			vbox.pack_start 	grid \
							,:expand 	=> false \
							,:fill 		=> false \
							,:padding 	=> 0 \


			add 			vbox
		end

		cancel_button.grab_focus
		show_all
	end
end

class Gtk_Settings < Gtk_Window
	def initialize settings, db, store, tree
		super()
		set_title 		title + " - Options"

		s 			= settings.s
		id_font_button 		= Gtk::FontButton.new s['id_font']
		url_font_button 	= Gtk::FontButton.new s['url_font']
		comment_font_button 	= Gtk::FontButton.new s['comment_font']
		tag_font_button 	= Gtk::FontButton.new s['tag_font']

		color_buttons = [ \
			[(color_button s['id_fg'])	  ,String.new] \
			,[(color_button s['url_fg'])	  ,String.new] \
			,[(color_button s['comment_fg'])  ,String.new] \
			,[(color_button s['tag_fg'])	  ,String.new]]
		
		0.step(color_buttons.size - 1, 1) do |i|
			color_buttons[i][0].signal_connect "color-set" do
				color_buttons[i][1] = color_buttons[i][0].color.to_s
			end
		end

		tree_style		= Gtk::ComboBoxText.new 
		tree_style.insert_text 	0, "Tree"
		tree_style.insert_text 	1, "Tag"
		tree_style.set_active 	s['style'].to_i
		t_tree_style 		= s['style']

		tree_style.signal_connect "changed" do |s|
			t_tree_style = s.active
		end

		tree_lines 		= Gtk::CheckButton.new "Tree lines", false
		tree_lines.tooltip_text = "draw lines linking tag/dirs and bookmarks?"

		if s['tree_lines'] == "true"
			tree_lines.set_active	true
		else
			tree_lines.set_active	false
		end

		url_underline 		= Gtk::CheckButton.new "Url underline", false
		tree_lines.tooltip_text = "draw underline in url's?"

		if s['url_underline'] == "true"
			url_underline.set_active	true
		else
			url_underline.set_active	false
		end

		user_agent_entry			= Gtk::Entry.new
		user_agent_entry.text			= s['user_agent']
		user_agent_entry.tooltip_text 		= "user agent string, used by webkit"
		user_agent_entry.primary_icon_pixbuf 	= (Actions.search_icon "web-browser-symbolic")
	
		xclip 			= Gtk::CheckButton.new "xclip?", false
		xclip.tooltip_text	= "use xclip to make copied text available system wide?"\
						" otherwise use default Gtk clipboard"

		if s['xclip'] == "true"
			xclip.set_active	true
		end

		enable_js 		= Gtk::CheckButton.new "enable javascript?", false
		enable_js.tooltip_text	= "enable webkit to use JavaScript?"

		if s['enable_javascript'] == "true"
			enable_js.set_active	true
		end

		auto_favicon 			= Gtk::CheckButton.new "auto download favicon?", false
		auto_favicon.tooltip_text 	= "automatically download favicon"\
							" when add a bookmark?"

		if s['auto_favicon'] == "true"
			auto_favicon.set_active	true
		end

		open_command_entry			= Gtk::Entry.new
		open_command_entry.text			= s['open_command']
		open_command_entry.tooltip_text 	= "command used to open url's"
		open_command_entry.primary_icon_pixbuf = (Actions.search_icon "gnome-globe")

		apply_button 		= Gtk::Button.new :stock_id => Gtk::Stock::APPLY
		cancel_button 		= Gtk::Button.new :stock_id => Gtk::Stock::CANCEL
		reset_button		= Gtk::Button.new :label => "_Reset"
		reset_button.use_underline = true

		ap_grid 		= Grid.new

								#e   #t   #l   #a
		ap_grid.attach (Gtk::Label.new "List:"),	0,   0,   5,   1
		ap_grid.attach tree_lines,			5,   0,   5,   1
		ap_grid.attach url_underline,  			10,  0,   5,   1
		ap_grid.attach (tree_style),   			5,   1,   5,   1
		ap_grid.attach (Gtk::Label.new ""),   		0,   2,   5,   1
		ap_grid.attach (Gtk::Label.new "Column"),   	0,   3,   5,   1
		ap_grid.attach (Gtk::Label.new "Foreground"),   5,   3,   5,   1
		ap_grid.attach (Gtk::Label.new "Font"),     	10,  3,   5,   1
		ap_grid.attach (Gtk::Label.new "Tag/Dir"),	0,   4,   5,   1
		ap_grid.attach color_buttons[3][0],		5,   4,   5,   1
		ap_grid.attach tag_font_button,			10,  4,   5,   1
		ap_grid.attach (Gtk::Label.new "Url"), 		0,   5,   5,   1
		ap_grid.attach color_buttons[1][0],		5,   5,   5,   1
		ap_grid.attach url_font_button,			10,  5,   5,   1
		ap_grid.attach (Gtk::Label.new "Comment"),	0,   6,   5,   1
		ap_grid.attach color_buttons[2][0],		5,   6,   5,   1
		ap_grid.attach comment_font_button,		10,  6,   5,   1
		ap_grid.attach (Gtk::Label.new "Id"),		0,   7,   5,   1
		ap_grid.attach color_buttons[0][0],		5,   7,   5,   1
		ap_grid.attach id_font_button,			10,  7,   5,   1

		bh_grid			= Grid.new

		bh_grid.attach (Gtk::Label.new "Open url command:"),	0,   0,   5,   1
		bh_grid.attach open_command_entry,			5,   0,   5,   1
		bh_grid.attach (Gtk::Label.new "Clipboard:"),		0,   1,   5,   1
		bh_grid.attach xclip,					5,   1,   5,   1
		bh_grid.attach (Gtk::Label.new "Favicons:"),		0,   2,   5,   1
		bh_grid.attach auto_favicon,				5,   2,   5,   1
		bh_grid.attach enable_js,				5,   3,   5,   1
		bh_grid.attach user_agent_entry,			5,   4,   5,   1

		tabs			= Gtk::Notebook.new
		tabs.append_page 	bh_grid, (Gtk::Label.new "Options")
		tabs.append_page 	ap_grid, (Gtk::Label.new "Appearance")

		vbox 			= Gtk::Box.new :vertical, 2
		vbox.pack_start 	tabs \
						,:expand 	=> false \
						,:fill 		=> false \
						,:padding 	=> 0

		button_box 		= Gtk::Box.new :horizontal, 2
		button_box.pack_start 	apply_button 
		button_box.pack_start 	cancel_button 
		button_box.pack_start 	reset_button 
		vbox.pack_start 	button_box \
						,:expand 	=> true \
						,:fill 		=> false \
						,:padding 	=> 0

		cancel_button.signal_connect "clicked" do
			destroy
		end

		apply_button.signal_connect "clicked" do
			s['id_fg'] 		= color_buttons[0][1] if !color_buttons[0][1].empty?
			s['url_fg'] 		= color_buttons[1][1] if !color_buttons[1][1].empty?
			s['comment_fg'] 	= color_buttons[2][1] if !color_buttons[2][1].empty?
			s['tag_fg'] 		= color_buttons[3][1] if !color_buttons[3][1].empty?

			s['id_font'] 		= id_font_button.font_name
			s['url_font']     	= url_font_button.font_name
			s['comment_font'] 	= comment_font_button.font_name
			s['tag_font']     	= tag_font_button.font_name

			s['style'] 		= t_tree_style

			s['user_agent'] 	= user_agent_entry.text

			s['open_command'] 	= open_command_entry.text

			if tree_lines.active?
				s['tree_lines'] = "true"
			else
				s['tree_lines'] = "false"
			end

			if url_underline.active?
				s['url_underline'] = "true"
			else
				s['url_underline'] = "none"
			end

			if xclip.active?
				s['xclip'] = "true"
			else
				s['xclip'] = "false"
			end

			if auto_favicon.active?
				s['auto_favicon'] = "true"
			else
				s['auto_favicon'] = "false"
			end

			settings.save_config
			store.style 		= s['style']
			Actions.store_feed	db, store, tree
			tree.load_settings	s
			destroy
		end

		reset_button.signal_connect "clicked" do
				s['id_fg'] 		= String.new 
				s['id_font'] 		= String.new
				s['url_fg'] 		= String.new
				s['url_font'] 		= String.new
				s['comment_fg'] 	= String.new
				s['comment_font']	= String.new
				s['tag_fg'] 		= String.new
				s['tag_font'] 		= String.new
				s['url_underline']	= "true"
				s['style']		= "0"
				s['show_toolbar']	= "true"
				s['show_filterbar']	= "true"
				s['xclip'] 		= "true"
				s['tree_lines'] 	= "false"
				s['auto_favicon'] 	= "true"
				s['enable_javascript']	= "false"
				s['open_command']	= "firefox -new-tab -url"
				s['user_agent']		= "Mozilla/5.0 (X11; Linux i686; rv:45.0) Gecko/20100101 Firefox/45.0"

			settings.save_config
			store.style 		= s['style']
			Actions.store_feed	db, store, tree
			tree.load_settings	s
			destroy
		end

		add 			vbox
		show_all
	end

	def color_button color
		button 			= Gtk::ColorButton.new 

		if !color.empty?
			button.color	= Gdk::Color.parse color 
		end

		button
	end
end

class Gtk_Ui < Gtk_Window
	def initialize 
		super
		set_default_size 	800, 600
		set_type_hint 		:normal

		signal_connect "destroy" do
			Gtk.main_quit
		end

		@settings 		= Settings.new
		@db 			= Db.new @settings.s['db']
		@store 			= Store.new @settings.s \
						,String \
						,Gdk::Pixbuf \
						,Gdk::Pixbuf \
						,String \
						,String \
						,String \
						,String

		@store.set_sort_column_id 6

		@tree 			= make_tree 

		Actions.store_feed 	@db, @store, @tree

		sw 			= Gtk::ScrolledWindow.new nil, nil
		sw.border_width 	= 2
		sw.add 			@tree

		vbox 			= Gtk::Box.new :vertical, 2

		@tool_bar 		= (make_toolbar make_tools, true) 
		@filter_bar 		= make_filter_box

		vbox.pack_start 	(make_menubar make_menu) \
						,:expand 	=> false \
						,:fill 		=> false

		vbox.pack_start 	@tool_bar \
						,:expand 	=> false \
						,:fill 		=> false

		vbox.pack_start 	sw 

		vbox.pack_start 	@filter_bar \
						,:expand 	=> false \
						,:fill 		=> false

		if @tree.model.iter_first
			@tree.set_cursor (@tree.model.iter_first).path, nil, false
			@tree.grab_focus
		end

		signal_connect "key-press-event" do |w, e|
			key = "#{Gdk::Keyval.to_name e.keyval}"

			if key == "Escape"
				@tree.grab_focus
			end

			if @tree.has_focus? 
				if !e.state.mod1_mask?
					if key == "v" 
						@tree.expand_all
					end

					if key == "x"
						@tree.collapse_all
					end

					if key == "j" \
					or key == "n" 
					#or key == "Down"
						@tree.move_cursor 	:display_lines, 1 
					end

					if key == "k" \
					or key == "p" 
					#or key == "Up"
						@tree.move_cursor 	:display_lines, -1 
					end

					if key == "g" \
					or key == "Home"
						@tree.move_cursor 	:buffer_ends, -1
					end

					if key == "G" \
					or key == "End"
						@tree.move_cursor 	:buffer_ends, 1
						cursor, column 		= @tree.cursor
						@tree.set_cursor 	cursor, nil, false
					end

					if key == "f" \
					#or key == "Page_Down"
						@tree.move_cursor 	:pages, 1
					end

					if key == "b" 
					#or key == "Page_Up"
						@tree.move_cursor 	:pages, -1
					end

					if key == "h" 
					#or key == "Left"
						sw.hadjustment.value 	= sw.hadjustment.value \
							- sw.hadjustment.step_increment
					end

					if key == "l" 
					#or key == "Right"
						sw.hadjustment.value 	= sw.hadjustment.value \
							+ sw.hadjustment.step_increment
					end

					if key == "0" \
					or key == "bar"
						sw.hadjustment.value	= sw.hadjustment.lower
					end

					if key == "dollar" 
						sw.hadjustment.value 	= sw.hadjustment.upper
					end

					if key == "o"
						if (ret = Actions.open 	@store, @tree, @settings, self)
							@db = ret
						end
					end

					if key == "i" \
					or key == "Insert"
						Actions.insert 		@db ,@store, @tree, @settings.s
					end

					if key == "t"
						@filter_bar.each do |item|
							if item.class == Gtk::Entry
								item.grab_focus	
								break
							end
						end
					end

					if key == "e"
						Actions.edit 		@db ,@store, @tree, @settings.s
					end

					if key == "d" \
					or key == "Delete"
						Actions.delete 		@db ,@store, @tree, @settings.s
					end

					if key == "s"
						Actions.settings 	@settings, @db, @store, @tree
					end

					if key == "r"
						Actions.store_feed 	@db, @store, @tree
					end

					if key == "u"
						Actions.open_bookmark 	@store, @tree, @settings.s
					end

					if key == "c"
						Actions.clipboard 	@store, @tree, @settings.s
					end

					#if key == "Menu"
					#	@tree.popup_menu
					#end

					cursor, column 			= @tree.cursor

					#if cursor \
					#and key == "Return"
					#	@tree.row_activated	cursor, column
					#end

					if cursor
						@tree.selected_row	= cursor
						#@tree.set_cursor 	cursor, nil, false
					end
				end

				if key == "Space" 
					@tree.select_cursor_row
				end
			end
		end

		add 			vbox
		show_all

		if @settings.s['show_toolbar'] == "false"
			@tool_bar.hide
		end

		if @settings.s['show_filterbar'] == "false"
			@filter_bar.hide
		end
	end

	def make_menu
		file_open 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::OPEN
		file_import 			= Gtk::ImageMenuItem.new :label => "_Import"
		file_import.use_underline 	= true
		file_import.image 		= Gtk::Image.new \
							:pixbuf => (Actions.search_icon "insert-object")
		file_exit 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::QUIT

		edit_fetch_db	 		= Gtk::ImageMenuItem.new :label => "_Reload"
		edit_fetch_db.use_underline 	= true
		edit_fetch_db.image 		= Gtk::Image.new \
							:pixbuf => (Actions.search_icon "reload")
		edit_fetch_fv	 		= Gtk::ImageMenuItem.new :label => "Fetch fa_vicon"
		edit_fetch_fv.use_underline 	= true
		edit_fetch_fv.image 		= Gtk::Image.new \
							:pixbuf => (Actions.search_icon \
								"starred-symbolic")
		edit_copy	 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::COPY
		edit_insert	 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::ADD
		edit_edit	 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::EDIT
		edit_delete	 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::DELETE
		edit_open			= Gtk::ImageMenuItem.new :label => "_Open bookmark"
		edit_open.use_underline		= true
		edit_open.image			= Gtk::Image.new \
							:pixbuf => (Actions.search_icon \
								"gnome-globe")
		edit_preferences 		= Gtk::ImageMenuItem.new \
							:stock_id => Gtk::Stock::PREFERENCES

		edit_toolbar			= Gtk::ImageMenuItem.new :label => "Show/hide _toolbar"
		edit_toolbar.use_underline 	= true
		edit_toolbar.image 		= Gtk::Image.new \
							:pixbuf => (Actions.search_icon \
								"gtk-properties")
		
		edit_filterbar			= Gtk::ImageMenuItem.new :label => "Show/hide _filterbar"
		edit_filterbar.use_underline 	= true
		edit_filterbar.image 		= Gtk::Image.new \
							:pixbuf => (Actions.search_icon \
								"gtk-properties")

		help_doc 			= Gtk::ImageMenuItem.new :label => "_Doc"
		help_doc.use_underline 		= true
		help_about 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::ABOUT

		file_open.signal_connect "activate" do
			if (ret = Actions.open @store, @tree, @settings, self)
				@db = ret
			end
		end

		file_import.signal_connect "activate" do
			Actions.import 		@db, self
			Actions.store_feed 	@db, @store, @tree
		end

		file_exit.signal_connect "activate" do
			Gtk.main_quit
		end

		edit_fetch_db.signal_connect "activate" do
			Actions.store_feed 	@db, @store, @tree
		end

		edit_fetch_fv.signal_connect "activate" do
			Actions.download_favicon @store, @tree, @settings.s
		end

		edit_copy.signal_connect "activate" do
			Actions.clipboard 	@store, @tree, @settings.s
		end

		edit_insert.signal_connect "activate" do
			Actions.insert 		@db, @store, @tree, @settings.s
		end

		edit_delete.signal_connect "activate" do
			Actions.delete 		@db, @store, @tree, @settings.s
		end

		edit_edit.signal_connect "activate" do
			Actions.edit 		@db, @store, @tree, @settings.s
		end

		edit_open.signal_connect "activate" do
			Actions.open_bookmark 	@store, @tree, @settings.s
		end

		edit_preferences.signal_connect "activate" do
			Actions.settings 	@settings, @db, @store, @tree
		end

		edit_toolbar.signal_connect "activate" do
			if @settings.s['show_toolbar'] == "true"
				@tool_bar.hide
				@settings.s['show_toolbar'] = "false"
			else
				@settings.s['show_toolbar'] = "true"
				@tool_bar.show
			end

			@settings.save_config
		end

		edit_filterbar.signal_connect "activate" do
			if @settings.s['show_filterbar'] == "true"
				@filter_bar.hide
				@settings.s['show_filterbar'] = "false"
			else
				@settings.s['show_filterbar'] = "true"
				@filter_bar.show
			end

			@settings.save_config
		end

		help_about.signal_connect "activate" do
			about 			= Gtk::AboutDialog.new 
			about.name 		= "poor man's bookmark"
			about.program_name 	= "pmb"
			about.version  		= "Version 0.1"
			about.comments		= "A simple bookmark manager"
			about.license		= "GNU GPL 2.0"
			about.copyright		= "GNU GPL 2.0"
			about.website 		= "https://github.com/neoncortex/poor-man-s-bookmark"
			about.authors		= ["neoncortex"]
			about.logo		= Actions.search_icon_with_size "gnome-globe", 64
			
			about.run
			about.destroy
		end

		menu_items = Hash[ \
			"file_open" 		=> file_open \
			,"file_import" 		=> file_import \
			,"file_exit" 		=> file_exit \
			,"edit_copy" 		=> edit_copy \
			,"edit_insert" 		=> edit_insert \
			,"edit_edit" 		=> edit_edit \
			,"edit_delete" 		=> edit_delete \
			,"edit_open"		=> edit_open \
			,"edit_fetch_db" 	=> edit_fetch_db \
			,"edit_fetch_fv" 	=> edit_fetch_fv \
			,"edit_toolbar" 	=> edit_toolbar \
			,"edit_preferences" 	=> edit_preferences \
			,"edit_filterbar" 	=> edit_filterbar \
			,"help_doc" 		=> help_doc \
			,"help_about" 		=> help_about]
	end

	def make_tools
		file_open 			= Gtk::ToolButton.new :stock_id => Gtk::Stock::OPEN

		file_import 			= Gtk::ToolButton.new 
		file_import.label 		= "Import"
		file_import.icon_name 		= "insert-object"

		file_exit 			= Gtk::ToolButton.new :stock_id => Gtk::Stock::QUIT

		edit_fetch_db	 		= Gtk::ToolButton.new 
		edit_fetch_db.label 		= "Reload"
		edit_fetch_db.icon_name		= "reload"

		edit_fetch_fv	 		= Gtk::ToolButton.new 
		edit_fetch_fv.label	 	= "Fetch favicon"
		edit_fetch_fv.icon_name		= "starred"

		edit_copy	 		= Gtk::ToolButton.new :stock_id => Gtk::Stock::COPY
		edit_insert	 		= Gtk::ToolButton.new :stock_id => Gtk::Stock::ADD
		edit_edit	 		= Gtk::ToolButton.new :stock_id => Gtk::Stock::EDIT
		edit_delete	 		= Gtk::ToolButton.new :stock_id => Gtk::Stock::DELETE
		edit_preferences 		= Gtk::ToolButton.new \
							:stock_id => Gtk::Stock::PREFERENCES
		edit_open			= Gtk::ToolButton.new 
		edit_open.label 		= "Open bookmark"
		edit_open.icon_name		= "gnome-globe"

		file_open.signal_connect "clicked" do
			if (ret = Actions.open @store, @tree, @settings, self)
				@db = ret
			end
		end

		file_import.signal_connect "clicked" do
			Actions.import 		@db, self
			Actions.store_feed 	@db, @store, @tree
		end

		file_exit.signal_connect "clicked" do
			Gtk.main_quit
		end

		edit_fetch_db.signal_connect "clicked" do
			Actions.store_feed 	@db, @store, @tree
		end

		edit_fetch_fv.signal_connect "clicked" do
			Actions.download_favicon @store, @tree, @settings.s
		end

		edit_copy.signal_connect "clicked" do
			Actions.clipboard 	@store, @tree, @settings.s
		end

		edit_insert.signal_connect "clicked" do
			Actions.insert 		@db, @store, @tree, @settings.s
		end

		edit_delete.signal_connect "clicked" do
			Actions.delete 		@db, @store, @tree, @settings.s
		end

		edit_open.signal_connect "clicked" do
			Actions.open_bookmark	@store, @tree, @settings.s
		end

		edit_edit.signal_connect "clicked" do
			Actions.edit 		@db, @store, @tree, @settings.s
		end

		edit_preferences.signal_connect "clicked" do
			Actions.settings 	@settings, @db, @store, @tree
		end

		tool_items = Hash[ \
			"file_open" 		=> file_open \
			,"file_import" 		=> file_import \
			,"file_exit" 		=> file_exit \
			,"edit_copy" 		=> edit_copy \
			,"edit_insert" 		=> edit_insert \
			,"edit_edit" 		=> edit_edit \
			,"edit_delete" 		=> edit_delete \
			,"edit_open"		=> edit_open \
			,"edit_fetch_db" 	=> edit_fetch_db \
			,"edit_fetch_fv" 	=> edit_fetch_fv \
			,"edit_preferences" 	=> edit_preferences] 
	end

	def make_menubar items
		file_item 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::FILE
		file_item.image 		= nil
		file_menu 			= Gtk::Menu.new
		file_item.set_submenu 		file_menu
		file_menu.append 		items['file_open']
		file_menu.append 		items['file_import']
		file_menu.append		Gtk::SeparatorMenuItem.new
		file_menu.append 		items['file_exit']

		edit_item 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::EDIT
		edit_item.image 		= nil
		edit_menu 			= Gtk::Menu.new
		edit_item.set_submenu 		edit_menu
		edit_menu.append 		items['edit_copy']
		edit_menu.append 		items['edit_open']
		edit_menu.append 		items['edit_fetch_db']
		edit_menu.append		Gtk::SeparatorMenuItem.new
		edit_menu.append 		items['edit_insert']
		edit_menu.append 		items['edit_edit']
		edit_menu.append 		items['edit_delete']
		edit_menu.append 		items['edit_fetch_fv']
		edit_menu.append		Gtk::SeparatorMenuItem.new
		edit_menu.append 		items['edit_toolbar']
		edit_menu.append 		items['edit_filterbar']
		edit_menu.append		Gtk::SeparatorMenuItem.new
		edit_menu.append 		items['edit_preferences']

		help_item 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::HELP
		help_item.image 		= nil
		help_menu 			= Gtk::Menu.new 
		help_item.set_submenu 		help_menu
		#help_menu.append		items['help_doc']
		help_menu.append		items['help_about']

		menu_bar 			= Gtk::MenuBar.new
		menu_bar.append 		file_item
		menu_bar.append 		edit_item
		menu_bar.append 		help_item
		menu_bar
	end

	def make_toolbar items, show_text
		tool_bar 		= Gtk::Toolbar.new

		if show_text
			tool_bar.toolbar_style	= :both
		end

		number_of_items		= 0
		tool_bar.insert 	items['file_open']		,number_of_items
		tool_bar.insert 	items['file_import']		,number_of_items += 1
		tool_bar.insert		Gtk::SeparatorToolItem.new	,number_of_items += 1
		tool_bar.insert 	items['edit_copy']		,number_of_items += 1
		tool_bar.insert 	items['edit_open']		,number_of_items += 1
		tool_bar.insert 	items['edit_fetch_db']		,number_of_items += 1
		tool_bar.insert		Gtk::SeparatorToolItem.new	,number_of_items += 1
		tool_bar.insert		items['edit_insert']		,number_of_items += 1
		tool_bar.insert 	items['edit_edit']		,number_of_items += 1
		tool_bar.insert		items['edit_delete']		,number_of_items += 1
		tool_bar.insert		items['edit_fetch_fv']		,number_of_items += 1
		tool_bar.insert		Gtk::SeparatorToolItem.new	,number_of_items += 1
		tool_bar.insert		items['edit_preferences']	,number_of_items += 1
		tool_bar
	end

	def make_tree_menu items
		menu 			= Gtk::Menu.new
		menu.append 		items['edit_copy']
		menu.append 		items['edit_open']
		menu.append 		items['edit_fetch_db']
		menu.append 		Gtk::SeparatorMenuItem.new
		menu.append 		items['edit_insert']
		menu.append 		items['edit_edit']
		menu.append 		items['edit_delete']
		menu.append 		items['edit_fetch_fv']
		menu.append 		Gtk::SeparatorMenuItem.new
		menu.append 		items['edit_preferences']
		menu.append 		Gtk::SeparatorMenuItem.new
		menu.append 		items['file_open']
		menu.append 		items['file_import']
		menu.append 		items['file_exit']
		menu.show_all
		menu
	end

	def make_tree 
		tree				= Tree.new @store
		tree.load_settings		@settings.s
		tree.search_column 		= @settings.s['search_column'].to_i
		tree.selection.mode		= :multiple
		tree.enable_search		= false

		icon_render 			= Gtk::CellRendererPixbuf.new
		favicon_render 			= Gtk::CellRendererPixbuf.new

		tag_column			= Gtk::TreeViewColumn.new "tag/dir"
		tag_column.pack_start 		icon_render, true
		tag_column.set_attributes 	icon_render, {:pixbuf => 1}

		tag_column.pack_start 		tree.render_tag, false
		tag_column.set_attributes 	tree.render_tag, {:text => 4}

		url_column			= Gtk::TreeViewColumn.new "url"
		url_column.pack_start 		favicon_render, true
		url_column.set_attributes 	favicon_render, {:pixbuf => 2}

		url_column.pack_start 		tree.render_url, false
		url_column.set_attributes 	tree.render_url, {:text => 3}

		tree.append_column 		tag_column
		tree.append_column 		url_column

		tree.insert_column 		2, "comment" \
							,tree.render_comment, {:text => 5}

		tree.insert_column 		3, "id" \
							,tree.render_id, {:text => 0}

		tree.signal_connect "row-activated" do |tree, path, col|
			if tree.row_expanded? path
				tree.collapse_row path
			else
				tree.expand_row path, nil
			end

			Actions.clipboard 	@store, @tree, @settings.s
		end

		menu		= make_tree_menu make_menu

		tree.signal_connect "button-press-event" do |tree, e|
			if e.kind_of? Gdk::EventButton and e.button == 3
				menu.popup nil, nil, e.button, e.time
			end
		end

		tree.signal_connect "popup_menu" do
			menu.popup nil, nil, 0, Gdk::Event::CURRENT_TIME
		end

		tree
	end

	def make_filter_box
		filter_label 			= Gtk::Label.new " Filter "
		filter_entry 			= Gtk::Entry.new
		filter_button 			= Gtk::Button.new :stock_id => Gtk::Stock::APPLY
		filter_entry.tooltip_text	= "filter bookmarks with inserted text"

		if (icon = Actions.search_icon "edit-find-symbolic")
			filter_entry.primary_icon_pixbuf = icon
			filter_entry.primary_icon_activatable = false
		end

		filter_button.signal_connect "clicked" do
			@store.filter 		= filter_entry.text
			Actions.store_feed 	@db, @store, @tree
		end

		filter_entry.signal_connect "activate" do
			@store.filter 		= filter_entry.text
			Actions.store_feed 	@db, @store, @tree
		end

		filter_box 			= Gtk::Box.new :horizontal, 2
		filter_box.pack_start 		filter_label \
							,:expand 	=> false \
							,:fill 		=> false

		filter_box.pack_start 		filter_entry \
							,:expand 	=> true \
							,:fill 		=> true 

		filter_box.pack_start 		filter_button \
							,:expand 	=> false \
							,:fill 		=> false

		filter_box
	end
end

Gtk.init
Gtk_Ui.new
Gtk.main

