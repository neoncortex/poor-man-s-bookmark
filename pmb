#!/usr/bin/env ruby

require 'gtk3'
require 'net/http'
require 'nokogiri'
require 'open-uri'	
require 'sqlite3'

class Db
	def initialize path
		begin
			@db = SQLite3::Database.open path
		rescue
			puts 		"can't open database"
			exit
		end

		@db.execute 	"CREATE TABLE IF NOT EXISTS bookmark" \
					"(id INTEGER PRIMARY KEY" \
					",name text" \
					",url text" \
					",comment text" \
					",tag text" \
					",UNIQUE(url))"
	end

	def insert data
		stm 		= @db.prepare "INSERT INTO bookmark " \
					"(name, url, comment, tag) VALUES(?,?,?,?)"
	
		stm.bind_param 	1, data[0]
		stm.bind_param 	2, data[1]
		stm.bind_param 	3, data[2]
		stm.bind_param 	4, data[3]

		begin
			rs 		= stm.execute
		rescue
			Actions.error "url already exists", false
		end
	end

	def import data
		stm 		= @db.prepare "INSERT OR IGNORE INTO bookmark " \
					"(name, url, comment, tag) VALUES(?,?,?,?)"
	
		stm.bind_param 	1, data[0]
		stm.bind_param 	2, data[1]
		stm.bind_param 	3, data[2]
		stm.bind_param 	4, data[3]
	end

	def delete id
		stm 		= @db.prepare "DELETE FROM bookmark " \
					"WHERE id = ?"	

		stm.bind_param	1, id
		rs 		= stm.execute
	end

	def delete_tag tag
		stm 		= @db.prepare "DELETE FROM bookmark " \
					"WHERE tag = ?"

		stm.bind_param 	1, tag
		rs 		= stm.execute
	end

	def edit id, field, value
		if field == "name" \
		or field == "url" \
		or field == "comment" \
		or field == "tag"
			stm 		= @db.prepare "UPDATE bookmark " \
						"SET #{field} = ? WHERE id = ?"

			stm.bind_param 	1, value
			stm.bind_param 	2, id
			rs 		= stm.execute
		end
	end

	def edit_tag tag, new_tag
		stm 		= @db.prepare "UPDATE bookmark " \
					"SET tag = ? WHERE tag = ?"

		stm.bind_param 	1, new_tag
		stm.bind_param 	2, tag
		rs 		= stm.execute
	end

	def find id
		stm 		= @db.prepare "SELECT * FROM bookmark " \
					"WHERE id = ? ORDER BY tag ASC"

		stm.bind_param 	1, id
		rs		= stm.execute
	end

	def fetch filter
		if filter
			stm 	= @db.prepare "SELECT * FROM bookmark " \
					"WHERE name LIKE '%%#{filter}%%' " \
					"OR url LIKE '%%#{filter}%%' " \
					"OR comment LIKE '%%#{filter}%%' " \
					"OR tag LIKE '%%#{filter}%%' " \
					"ORDER BY tag ASC"
		else
			stm 	= @db.prepare "SELECT * from bookmark " \
					"ORDER BY tag ASC"
		end

		rs 		= stm.execute
	end
end

class Settings
	def initialize
		@s = Hash[ \
			"dir" 			=> "#{ENV['HOME']}/.config/" \
							"pmb" \
			,"config" 		=> "config" \
			,"db" 			=> "#{ENV['HOME']}/.config/" \
							"pmb/bookmarks.db" \
			,"id_fg" 		=> String.new \
			,"id_bg" 		=> String.new \
			,"id_font" 		=> String.new \
			,"name_fg" 		=> String.new \
			,"name_bg" 		=> String.new \
			,"name_font" 		=> String.new \
			,"url_fg" 		=> String.new \
			,"url_bg" 		=> String.new \
			,"url_font" 		=> String.new \
			,"comment_fg" 		=> String.new \
			,"comment_bg"		=> String.new \
			,"comment_font"		=> String.new \
			,"tag_fg" 		=> String.new \
			,"tag_bg" 		=> String.new \
			,"tag_font" 		=> String.new \
			,"style"		=> "0" \
			,"search_column" 	=> "1" \
			,"xclip" 		=> "true" \
			,"tree_lines" 		=> "true"]

		if !(File.exists? "#{@s['dir']}")
			Dir.mkdir "#{@s['dir']}"
		end

		if !(File.exists? "#{@s['dir']}/favicon")
			Dir.mkdir "#{@s['dir']}/favicon"
		end

		if !(File.exists? "#{@s['dir']}/#{@s['config']}")
			save_config
		else
			load_config
		end
	end

	def save_config
		File.open("#{@s['dir']}/#{@s['config']}", "w") do |f|
			f.write "#DO NOT EDIT BY HAND\n\n"

			@s.each do |i|
				f.write "#{i[0]} = #{i[1]}\n"
			end
		end
	end

	def load_config
		File.open("#{@s['dir']}/#{@s['config']}", "r") do |f|
			while l = f.gets do
				if @s[l[/(^.*?\s)/][0...-1]]
					@s[l[/(^.*?\s)/][0...-1]] = l[/(?<==\s).*/]
				end
			end
		end
	end

	attr_accessor :s
end

class Web_Data
	def self.favicon_exist? path
		if (File.exists? "#{path}/favicon.ico")
			return true
		end

		nil
	end

	def self.favicon_download url, file
		uri 	= URI url

		begin 
			http 	= Net::HTTP.start uri.host \
					,:read_timeout 	=> 1.000 \
					,:use_https 	=> uri.scheme == 'https'

			if file
				if file[0] == '/'
					icon 	= http.get file
				elsif file[0] == '/'and file[1] == '/'
					icon 	= http.get file[2..-1]
				else
					icon 	= http.get "/#{file}"
				end
			else
				file 	= url[/[^(http|https):\/\/"#{uri.host}"\/].*/]
				icon 	= http.get "/#{file}"
			end

			if icon.message == "Redirect" \
			or icon.message == "Moved Permanently" \
			or icon.message == "Moved Temporarily" 
				return (Net::HTTP.get (URI icon['location']))
			elsif icon.message == "Not Found"
				nil
			else
				return icon.body
			end
		rescue Exception => e #ugly, anyway ..
			nil
		end
	end

	def self.favicon_fetch url
		begin
			uri 	= URI url
			page 	= Net::HTTP.get uri
			page_p  = Nokogiri page
			link 	= page_p.css("link")

			for i in link do
				if i['rel']
					if i['rel'].downcase == "shortcut icon" \
					or i['rel'].downcase == "icon" \
					or i['rel'].downcase == "apple-touch-icon" 
						if i['href'][/^(http|https)/]
							return (Net::HTTP.get (URI i['href']))
						elsif i['href'][/^\./]
							return (favicon_download url, "favicon.ico")
						else
							return (favicon_download url, i['href'])
						end
					end
				end
			end

			return (favicon_download url, "favicon.ico")
		rescue Exception => e
			nil
		end
	end

	def self.favicon_write path, icon
		png 	= Regexp.new("\x89PNG".force_encoding("binary"))
		jpg 	= Regexp.new("\xff\xd8\xff\xe0\x00\x10JFIF".force_encoding("binary"))
		jpg2	= Regexp.new("\xff\xd8\xff\xe1(.*){2}Exif".force_encoding("binary"))

		if icon[0,4] == "\x00\x00\x01\x00" \
		or icon[/^#{png}/] \
		or icon[/^#{jpg}/] \
		or icon[/^#{jpg2}/]
			if !(File.exists? path)
				Dir.mkdir path
			end

			File.open("#{path}/favicon.ico", "wb") do |f|
				f.write icon
			end
		end
	end
end

class Actions
	def self.clipboard store, tree, xclip
		url 	= store.get_value \
				(tree.selection).selected, 3

		if xclip == "true"
			Process.detach spawn \
				"echo '#{url}' | xclip -i -selection 'primary'"

			Process.detach spawn \
				"echo '#{url}' | xclip -i -selection 'secoundary'"

			Process.detach spawn \
				"echo '#{url}' | xclip -i -selection 'clipboard'"
		else
			clip_p = Gtk::Clipboard.get Gdk::Selection::PRIMARY
			clip_c = Gtk::Clipboard.get Gdk::Selection::CLIPBOARD

			clip_p.text = url
			clip_c.text = url

			clip_p.store
			clip_c.store
		end
	end

	def self.store_feed db, store, tree
		store.clear
		
		if store.style.to_i == 0
			store.feed_tree		(db.fetch store.filter)
		else
			store.feed_tag		(db.fetch store.filter)
		end

		tree.expand_all

		if tree.selected_row
			tree.set_cursor 	tree.selected_row, nil, false
			tree.scroll_to_cell 	tree.selected_row, nil, true, 0.5, 0.0
		end
	end

	def self.open store, tree, settings, window
		chooser = Gtk::FileChooserDialog.new \
			:title 		=> "Open" \
			,:parent 	=> window \
			,:action 	=> :save \
			,:buttons 	=> [ \
				[Gtk::Stock::CANCEL, :cancel] \
				,[Gtk::Stock::OPEN, :accept]]

		db 	= nil

		if chooser.run == Gtk::ResponseType::ACCEPT
			begin
				db 			= Db.new chooser.filename
				settings.s['db'] 	= chooser.filename
				chooser.destroy

				Actions.store_feed 	db, store, tree
				settings.save_config
			rescue
				chooser.destroy
				Actions.error 		"Error opening file", false
			end
		else
			chooser.destroy
		end

		if db
			db
		end
	end

	def self.import db_ex, window
		chooser = Gtk::FileChooserDialog.new \
			:title 		=> "Open" \
			,:parent 	=> window \
			,:action 	=> :open \
			,:buttons 	=> [ \
				[Gtk::Stock::CANCEL, :cancel] \
				,[Gtk::Stock::OPEN, :accept]]

		if chooser.run == Gtk::ResponseType::ACCEPT
			begin
				db 		= Db.new chooser.filename
				r 		= db.fetch nil

				for i in r do
					db_ex.import [i[1], i[2], i[3], i[4]]
				end

				chooser.destroy
			rescue
				chooser.destroy
				Actions.error 	"Error importing file", false
			end
		else
			chooser.destroy
		end
	end

	def self.insert db, store, tree, s
		tree.selected_row 	= tree.selection.selected.path
		Gtk_Insert.new 		db, store, tree, s
	end

	def self.edit db, store, tree, s
		if tree.model.iter_first
			tree.selected_row 	= tree.selection.selected.path
			Gtk_Edit.new 		db, store, tree, s
		else
			error "Nothing to edit.", false
		end
	end

	def self.delete db, store, tree, s
		if tree.model.iter_first
			tree.selected_row 	= tree.selection.selected.path
			Gtk_Delete.new 		db, store, tree, s
		else
			error "Nothing to delete.", false
		end
	end

	def self.error message, fatal
		Gtk_Error.new 		message, fatal
	end

	def self.settings settings, db, store, tree
		tree.selected_row 	= tree.selection.selected.path
		Gtk_Settings.new 	settings, db, store, tree
	end

	def self.search_icon icon
		icon_theme 	= Gtk::IconTheme.default

		if icon_theme.has_icon? icon
			r = icon_theme.load_icon icon \
				,16, Gtk::IconTheme::LookupFlags::FORCE_SIZE
			return r
		end

		nil
	end
end

class Store < Gtk::TreeStore
	attr_accessor :filter, :style

	def initialize *args
		super(*args[1..-1])
		@s		= args[0]
		@style 		= @s['style'].to_i
	end

	def search_toplevel entry
		each do |s, tp, it|
			if entry == (get_value it, 4) \
			and !it.parent
				return it
			end
		end

		false
	end

	def search_children entry, parent
		each do |s, tp, it|
			if entry == (get_value it, 4) \
			and parent == (get_value it.parent, 4)
				return it
			end
		end

		false
	end

	def set_icon url
		if url and url[/^(http|https)/]
			uri 	= URI url
			path	= "#{@s['dir']}/favicon/#{uri.host}"

			if Web_Data.favicon_exist? path
				begin
					icon = Gdk::Pixbuf.new "#{path}/favicon.ico", 20, 20
				rescue
					icon = Actions.search_icon "starred-symbolic"
				end
			else
				icon = Actions.search_icon "starred-symbolic"
			end
		
			return icon
		end

		nil
	end

	def feed_tree result
		number_of_items = 0

		for i in result do
			dirs 	= i[4].split '/'
			iter 	= nil

			dirs.each_with_index do |d, j|
				if j == 0
					if !(iter = search_toplevel d)
						iter = insert nil, number_of_items += 1 \
							,["" \
							,"" \
							,nil \
							,"" \
							,"#{d}" \
							,"" \
							,"#{i[4]}"]
					end
				else
					if !(r = search_children d, dirs[j - 1]) 
						if dirs[j]
							iter = insert iter, number_of_items += 1 \
								,["" \
								,"" \
								,nil \
								,"" \
								,"#{d}" \
								,"" \
								,"#{i[4]}"]
						end
					else
						iter = r
					end
				end
			end

			insert iter, number_of_items += 1 \
				,["#{i[0]}" \
				,"#{i[1]}" \
				,(set_icon i[2]) \
				,"#{i[2]}" \
				,"." \
				,"#{i[3]}" \
				,"#{i[4]}"]

			icon = nil
		end
	end

	def feed_tag result
		last 			= nil
		number_of_items 	= 0

		for i in result do
			if !last or i[4] != last
				iter = insert nil, number_of_items += 1 \
					,["" \
					,"" \
					,nil \
					,"" \
					,"#{i[4]}" \
					,"" \
					,"#{i[4]}"]
			end

			insert iter, number_of_items += 1 \
				,["#{i[0]}" \
				,"#{i[1]}" \
				,(set_icon i[2]) \
				,"#{i[2]}" \
				,"" \
				,"#{i[3]}" \
				,"#{i[4]}"]

			last	= i[4]
			icon	= nil
		end
	end
end

class Tree < Gtk::TreeView
	def initialize store
		super store
		@render_id 		= Gtk::CellRendererText.new
		@render_name		= Gtk::CellRendererText.new
		@render_url 		= Gtk::CellRendererText.new
		@render_comment		= Gtk::CellRendererText.new
		@render_tag 		= Gtk::CellRendererText.new
		@selected_row 		= nil
	end

	def parse_color render, color_fg, color_bg
		if !color_fg.empty?
			render.foreground_gdk 	= Gdk::Color.parse color_fg
		else
			render.foreground 	= nil
		end

		if !color_bg.empty?
			render.background_gdk 	= Gdk::Color.parse color_bg
		else
			render.background 	= nil
		end
	end

	def parse_font render, font
		if !font.empty?
			render.font 	= font
		else
			render.font 	= nil
		end
	end

	def load_settings s
		parse_color 	@render_id, s['id_fg'], s['id_bg']
		parse_color 	@render_name, s['name_fg'], s['name_bg']
		parse_color 	@render_url, s['url_fg'], s['url_bg']
		parse_color 	@render_comment, s['comment_fg'], s['comment_bg']
		parse_color 	@render_tag, s['tag_fg'], s['tag_bg']

		parse_font 	@render_id, s['id_font']
		parse_font 	@render_name, s['name_font']
		parse_font 	@render_url, s['url_font']
		parse_font 	@render_comment, s['comment_font']
		parse_font 	@render_tag, s['tag_font']

		if s['tree_lines'] == "true"
			self.enable_tree_lines  = true
		else
			self.enable_tree_lines  = false
		end

		columns_autosize
	end

	attr_reader \
		:render_id \
		,:render_name \
		,:render_url \
		,:render_comment \
		,:render_tag 

	attr_accessor :tree_lines, :selected_row
end

class Grid < Gtk::Grid
	def initialize
		super
		set_property 		"row-homogeneous"	,true
		set_property 		"column-homogeneous"	,true
	end
end

class Gtk_Window < Gtk::Window
	def initialize 
		super
		set_wmclass 		"Poor man's bookmark"	,"Pmb"
		set_title 		"Poor man's bookmark"
		set_type_hint 		:dialog

		signal_connect "destroy" do
			destroy
		end
	end

	def search_favicon url, s
		if url and url[/^(http|https)/]
			uri 	= URI url
			path	= "#{s['dir']}/favicon/#{uri.host}"

			if Web_Data.favicon_exist? path
				begin
					return (Gdk::Pixbuf.new "#{path}/favicon.ico", 20, 20)
				rescue
					return nil
				end
			end
		end

		nil
	end

	def create_name_entry
		name_entry 			= Gtk::Entry.new

		if (icon = Actions.search_icon "insert-text-symbolic")
			name_entry.primary_icon_pixbuf = icon
			name_entry.primary_icon_activatable = false
		end

		name_entry
	end

	def create_url_entry favicon
		url_entry 			= Gtk::Entry.new

		if favicon
			url_entry.primary_icon_pixbuf = favicon
		else
			if (icon = Actions.search_icon "starred-symbolic")
				url_entry.primary_icon_pixbuf = icon
			end
		end

		url_entry.primary_icon_activatable = false
		url_entry
	end

	def create_comment_entry
		comment_entry 			= Gtk::Entry.new

		if (icon = Actions.search_icon "insert-text-symbolic")
			comment_entry.primary_icon_pixbuf = icon
			comment_entry.primary_icon_activatable = false
		end

		comment_entry
	end

	def create_tag_entry
		tag_entry 			= Gtk::Entry.new

		if (icon = Actions.search_icon "insert-text-symbolic")
			tag_entry.primary_icon_pixbuf = icon
			tag_entry.primary_icon_activatable = false
		end

		tag_entry
	end
end

class Gtk_Error < Gtk_Window
	def initialize message, fatal
		super()
		set_title 		title + " - Error"

		error_label 		= Gtk::Label.new 
		error_label.set_markup	"<span foreground='red' " \
						"font-weight='heavy' " \
						"size='large'>" \
						"Error \n" \
						"</span>"

		error 			= Gtk::Label.new message
		close_button 		= Gtk::Button.new :stock_id => Gtk::Stock::CLOSE

		close_button.signal_connect "clicked" do
			if fatal
				Gtk.main_quit
			else
				destroy
			end
		end

		grid 				= Grid.new

						#e   #t   #l    #a
		grid.attach error_label, 	0,   0,   20,   1
		grid.attach error, 		0,   1,   20,   1
		grid.attach close_button, 	0,   2,   20,   1

		vbox 				= Gtk::Box.new :vertical, 2
		vbox.pack_start 		grid \
							,:expand => false \
							,:fill => false \
							,:padding => 0 \

		add 				vbox
		show_all
	end
end

class Gtk_Insert < Gtk_Window
	def initialize db, store, tree, s
		super()
		set_title 			title + " - Insert"

		name_entry 			= create_name_entry
		url_entry 			= create_url_entry nil
		comment_entry 			= create_comment_entry
		tag_entry 			= create_tag_entry
		insert_button 			= Gtk::Button.new :stock_id => Gtk::Stock::ADD
		cancel_button 			= Gtk::Button.new :stock_id => Gtk::Stock::CANCEL

		insert_button.signal_connect "clicked" do
			if (name_entry.text).size > 0 and (url_entry.text).size > 0
				name		= name_entry.text
				url 		= url_entry.text

				if (comment_entry.text).size == 0
					comment 	= "none"
				else
					comment 	= comment_entry.text
				end

				if (tag_entry.text).size == 0
					tag 		= "none"
				else
					tag 		= tag_entry.text
				end

				uri 	= URI url
				path	= "#{s['dir']}/favicon/#{uri.host}"

				if !Web_Data.favicon_exist? path
					if (icon = Web_Data.favicon_fetch url)
						Web_Data.favicon_write path, icon
					end
				end

				db.insert 		[name, url, comment, tag]
				Actions.store_feed 	db, store, tree
				destroy
			else
				Actions.error "Need at least name and url", false
			end
		end

		cancel_button.signal_connect "clicked" do
			destroy
		end

		grid 			= Grid.new

								#e   #t   #l    #a
		grid.attach (Gtk::Label.new "Name"), 		0,   0,   20,   1
		grid.attach name_entry, 			20,  0,   20,   1
		grid.attach (Gtk::Label.new "Url"), 		0,   1,   20,   1
		grid.attach url_entry,				20,  1,   20,   1
		grid.attach (Gtk::Label.new "Comment"),		0,   2,   20,   1
		grid.attach comment_entry,			20,  2,   20,   1
		grid.attach (Gtk::Label.new "Tag"), 		0,   3,   20,   1
		grid.attach tag_entry,				20,  3,   20,   1
		grid.attach insert_button,			0,   4,   20,   1
		grid.attach cancel_button,			20,  4,   20,   1

		vbox 			= Gtk::Box.new :vertical, 2
		vbox.pack_start 	grid \
						,:expand 	=> false \
						,:fill 		=> false \
						,:padding 	=> 0 \

		add 			vbox
		show_all
	end
end

class Gtk_Edit < Gtk_Window
	def initialize db, store, tree, s
		super()
		set_title 		title + " - Edit"

		id 			= store.get_value (tree.selection).selected, 0
		name 			= store.get_value (tree.selection).selected, 1
		url  			= store.get_value (tree.selection).selected, 3
		comment 		= store.get_value (tree.selection).selected, 5
		tag 			= store.get_value (tree.selection).selected, 6


		tag_entry 		= create_tag_entry
		tag_entry.set_text 	tag

		edit_button 		= Gtk::Button.new :stock_id => Gtk::Stock::APPLY
		cancel_button 		= Gtk::Button.new :stock_id => Gtk::Stock::CANCEL
		grid 			= Grid.new

		if url.empty?
			set_title 	title + " - Edit tag"
			old_tag 	= store.get_value \
							(tree.selection).selected, 6

			tag_entry.set_text old_tag

			tag_entry.signal_connect "activate" do
				db.edit_tag 		old_tag, tag_entry.text
				Actions.store_feed 	db, store, tree
				destroy
			end
			
			edit_button.signal_connect "clicked" do
				db.edit_tag 		old_tag, tag_entry.text
				Actions.store_feed 	db, store, tree
				destroy
			end
								#e   #t   #l    #a
			grid.attach (Gtk::Label.new "Tag"),	0,   1,   20,   1
			grid.attach tag_entry, 			20,  1,   20,   1
			grid.attach edit_button,		0,   2,   20,   1
			grid.attach cancel_button,		20,  2,   20,   1

		else
			name_entry 		= create_name_entry
			name_entry.set_text 	name

			if (favicon = search_favicon url, s)
				url_entry 	= create_url_entry favicon
			else
				url_entry 	= create_url_entry nil
			end

			url_entry.set_text	url

			comment_entry 		= create_comment_entry
			comment_entry.set_text	comment

			edit_button.signal_connect "clicked" do
				if name != name_entry.text 
					db.edit id, "name", name_entry.text
				end

				if url != url_entry.text 
					db.edit id, "url", url_entry.text
				end

				if comment != comment_entry.text 
					db.edit id, "comment", comment_entry.text
				end

				if tag != tag_entry.text
					db.edit id, "tag", tag_entry.text
				end

				Actions.store_feed 	db, store, tree
				destroy
			end

								#e   #t   #l    #a
			grid.attach (Gtk::Label.new "Name"),	0,   1,   20,   1
			grid.attach name_entry, 		20,  1,   20,   1
			grid.attach (Gtk::Label.new "Url"), 	0,   2,   20,   1
			grid.attach url_entry,			20,  2,   20,   1
			grid.attach (Gtk::Label.new "Comment"),	0,   3,   20,   1
			grid.attach comment_entry,		20,  3,   20,   1
			grid.attach (Gtk::Label.new "Tag"), 	0,   4,   20,   1
			grid.attach tag_entry,			20,  4,   20,   1
			grid.attach edit_button,		0,   5,   20,   1
			grid.attach cancel_button,		20,  5,   20,   1
		end

		cancel_button.signal_connect "clicked" do
			destroy
		end

		vbox 			= Gtk::Box.new :vertical, 2
		vbox.pack_start 	grid \
						,:expand 	=> false \
						,:fill 		=> false \
						,:padding 	=> 0 \

		add 			vbox
		show_all
	end
end

class Gtk_Delete < Gtk_Window
	def initialize db, store, tree, s
		super()
		set_title 			title + " - Delete?"

		id 		= store.get_value (tree.selection).selected, 0
		name 		= store.get_value (tree.selection).selected, 1
		url 		= store.get_value (tree.selection).selected, 3
		comment 	= store.get_value (tree.selection).selected, 5
		tag 		= store.get_value (tree.selection).selected, 6

		tag_entry 			= create_tag_entry
		tag_entry.set_text 		tag
		tag_entry.set_editable 		false

		delete_button 			= Gtk::Button.new :stock_id => Gtk::Stock::DELETE
		cancel_button 			= Gtk::Button.new :stock_id => Gtk::Stock::CANCEL
		grid 				= Grid.new

		if url.empty?
			grid.attach (Gtk::Label.new "Tag"), 	0,   0,   20,   1
			grid.attach tag_entry, 			20,  0,   20,   1
			grid.attach delete_button,		0,   1,   20,   1
			grid.attach cancel_button,		20,  1,   20,   1
		else
			name_entry 			= create_name_entry
			name_entry.set_text 		name
			name_entry.set_editable 	false

			if (favicon = search_favicon url, s)
				url_entry 	= create_url_entry favicon
			else
				url_entry 	= create_url_entry nil
			end

			url_entry.set_text 		url
			url_entry.set_editable 		false

			comment_entry 			= create_comment_entry
			comment_entry.set_text 		comment
			comment_entry.set_editable 	false

			grid.attach (Gtk::Label.new "Name"), 	0,   0,   20,   1
			grid.attach name_entry, 		20,  0,   20,   1
			grid.attach (Gtk::Label.new "Url"), 	0,   1,   20,   1
			grid.attach url_entry,			20,  1,   20,   1
			grid.attach (Gtk::Label.new "Comment"),	0,   2,   20,   1
			grid.attach comment_entry,		20,  2,   20,   1
			grid.attach (Gtk::Label.new "Tag"), 	0,   3,   20,   1
			grid.attach tag_entry,			20,  3,   20,   1
			grid.attach delete_button,		0,   4,   20,   1
			grid.attach cancel_button,		20,  4,   20,   1
		end

		delete_button.signal_connect "clicked" do
			if url.empty?
				db.delete_tag 		tag
			else
				db.delete 		id
			end

			Actions.store_feed 	db, store, tree
			destroy
		end

		cancel_button.signal_connect "clicked" do
			destroy
		end

		vbox 			= Gtk::Box.new :vertical, 2
		vbox.pack_start 	grid \
						,:expand 	=> false \
						,:fill 		=> false \
						,:padding 	=> 0 \

		cancel_button.grab_focus
		add 			vbox
		show_all
	end
end

class Gtk_Settings < Gtk_Window
	def initialize settings, db, store, tree
		super()
		set_title 		title + " - Options"

		s 			= settings.s
		id_font_button 		= Gtk::FontButton.new s['id_font']
		name_font_button 	= Gtk::FontButton.new s['name_font']
		url_font_button 	= Gtk::FontButton.new s['url_font']
		comment_font_button 	= Gtk::FontButton.new s['comment_font']
		tag_font_button 	= Gtk::FontButton.new s['tag_font']

		color_buttons = [ \
			[(color_button s['id_fg'])	  ,String.new] \
			,[(color_button s['id_bg'])	  ,String.new] \
			,[(color_button s['name_fg'])	  ,String.new] \
			,[(color_button s['name_bg'])	  ,String.new] \
			,[(color_button s['url_fg'])	  ,String.new] \
			,[(color_button s['url_bg'])	  ,String.new] \
			,[(color_button s['comment_fg'])  ,String.new] \
			,[(color_button s['comment_bg'])  ,String.new] \
			,[(color_button s['tag_fg'])	  ,String.new] \
			,[(color_button s['tag_bg'])	  ,String.new]] 

		0.step(color_buttons.size - 1, 1) do |i|
			color_buttons[i][0].signal_connect "color-set" do
				color_buttons[i][1] = color_buttons[i][0].color.to_s
			end
		end

		tree_style		= Gtk::ComboBoxText.new 
		tree_style.insert_text 	0, "Tree"
		tree_style.insert_text 	1, "Tag"
		tree_style.set_active 	s['style'].to_i
		t_tree_style 		= s['style']

		tree_style.signal_connect "changed" do |s|
			t_tree_style = s.active
		end

		tree_lines 		= Gtk::CheckButton.new "Tree lines", false

		if s['tree_lines'] == "true"
			tree_lines.set_active	true
		else
			tree_lines.set_active	false
		end

		grid 			= Grid.new

								#e   #t   #l   #a
		grid.attach (Gtk::Label.new "List:"),		0,   0,   5,   1
		grid.attach tree_lines,				5,   0,   5,   1
		grid.attach (tree_style),   			10,  0,   5,   1
		grid.attach (Gtk::Label.new ""),   		0,   1,   5,   1
		grid.attach (Gtk::Label.new "Column"),   	0,   2,   5,   1
		grid.attach (Gtk::Label.new "Foreground"),     	5,   2,   5,   1
		grid.attach (Gtk::Label.new "Background"),     	10,  2,   5,   1
		grid.attach (Gtk::Label.new "Font"),     	15,  2,   5,   1
		grid.attach (Gtk::Label.new "Id"),		0,   3,   5,   1
		grid.attach color_buttons[0][0],		5,   3,   5,   1
		grid.attach color_buttons[1][0],		10,  3,   5,   1
		grid.attach id_font_button,			15,  3,   5,   1
		grid.attach (Gtk::Label.new "Name"),		0,   4,   5,   1
		grid.attach color_buttons[2][0],		5,   4,   5,   1
		grid.attach color_buttons[3][0],		10,  4,   5,   1
		grid.attach name_font_button,			15,  4,   5,   1
		grid.attach (Gtk::Label.new "Url"), 		0,   5,   5,   1
		grid.attach color_buttons[4][0],		5,   5,   5,   1
		grid.attach color_buttons[5][0],		10,  5,   5,   1
		grid.attach url_font_button,			15,  5,   5,   1
		grid.attach (Gtk::Label.new "Comment"),		0,   6,   5,   1
		grid.attach color_buttons[6][0],		5,   6,   5,   1
		grid.attach color_buttons[7][0],		10,  6,   5,   1
		grid.attach comment_font_button,		15,  6,   5,   1
		grid.attach (Gtk::Label.new "Tag"), 		0,   7,   5,   1
		grid.attach color_buttons[8][0],		5,   7,   5,   1
		grid.attach color_buttons[9][0],		10,  7,   5,   1
		grid.attach tag_font_button,			15,  7,   5,   1

		frame 			= Gtk::Frame.new "Appearance"
		frame.add 		grid

		vbox 			= Gtk::Box.new :vertical, 2

		vbox.pack_start 	frame \
						,:expand 	=> false \
						,:fill 		=> false \
						,:padding 	=> 0

		apply_button 			= Gtk::Button.new :stock_id => Gtk::Stock::APPLY
		cancel_button 			= Gtk::Button.new :stock_id => Gtk::Stock::CANCEL

		button_box 		= Gtk::Box.new :horizontal, 2
		button_box.pack_start 	apply_button 
		button_box.pack_start 	cancel_button 

		vbox.pack_start 	button_box \
						,:expand 	=> true \
						,:fill 		=> false \
						,:padding 	=> 0

		cancel_button.signal_connect "clicked" do
			destroy
		end

		apply_button.signal_connect "clicked" do
			s['id_fg'] 		= color_buttons[0][1] if !color_buttons[0][1].empty?
			s['id_bg'] 		= color_buttons[1][1] if !color_buttons[1][1].empty?
			s['name_fg'] 		= color_buttons[2][1] if !color_buttons[2][1].empty?
			s['name_bg'] 		= color_buttons[3][1] if !color_buttons[3][1].empty?
			s['url_fg'] 		= color_buttons[4][1] if !color_buttons[4][1].empty?
			s['url_bg'] 		= color_buttons[5][1] if !color_buttons[5][1].empty?
			s['comment_fg'] 	= color_buttons[6][1] if !color_buttons[6][1].empty?
			s['comemnt_bg'] 	= color_buttons[7][1] if !color_buttons[7][1].empty?
			s['tag_fg'] 		= color_buttons[8][1] if !color_buttons[8][1].empty?
			s['tag_bg'] 		= color_buttons[9][1] if !color_buttons[9][1].empty?

			s['style'] 		= t_tree_style

			if tree_lines.active?
				s['tree_lines'] = "true"
			else
				s['tree_lines'] = "false"
			end

			s['id_font'] 		= id_font_button.font_name
			s['name_font']    	= name_font_button.font_name
			s['url_font']     	= url_font_button.font_name
			s['comment_font'] 	= comment_font_button.font_name
			s['tag_font']     	= tag_font_button.font_name

			settings.save_config
			store.style 		= s['style'].to_i
			Actions.store_feed	db, store, tree
			tree.load_settings	s
			destroy
		end

		add 			vbox
		show_all
	end

	def color_button color
		button 			= Gtk::ColorButton.new 

		if !color.empty?
			button.color	= Gdk::Color.parse color 
		end

		button
	end
end

class Gtk_Ui < Gtk_Window
	def initialize 
		super
		set_default_size 	800, 600
		set_type_hint 		:normal

		signal_connect "destroy" do
			Gtk.main_quit
		end

		@settings 		= Settings.new
		@db 			= Db.new @settings.s['db']
		@store 			= Store.new @settings.s, String, String \
						,Gdk::Pixbuf, String, String, String, String
		@tree 			= make_tree 

		Actions.store_feed 	@db, @store, @tree

		sw 			= Gtk::ScrolledWindow.new nil, nil
		sw.border_width 	= 2
		sw.add 			@tree

		vbox 			= Gtk::Box.new :vertical, 2

		vbox.pack_start 	(make_menubar make_menu) \
						,:expand 	=> false \
						,:fill 		=> false

		vbox.pack_start 	sw 

		filter_box 		= make_filter_box
		vbox.pack_start 	filter_box \
						,:expand 	=> false \
						,:fill 		=> false

		if @tree.model.iter_first
			@tree.set_cursor (@tree.model.iter_first).path, nil, false
			@tree.grab_focus
		end

		signal_connect "key-press-event" do |w, e|
			key = "#{Gdk::Keyval.to_name e.keyval}"

			if key == "Escape"
				@tree.grab_focus
			end

			if e.state.control_mask?
				if key == "a" 
					@tree.expand_all
				end

				if key == "x"
					@tree.collapse_all
				end

				if key == "j" or key == "n"
					@tree.move_cursor :display_lines, 1 
				end

				if key == "k" or key == "p"
					@tree.move_cursor :display_lines, -1 
				end

				if key == "g"
					@tree.move_cursor :buffer_ends, -1
				end

				if key == "G"
					@tree.move_cursor :buffer_ends, 1
				end

				if key == "f"
					@tree.move_cursor :pages, 1
				end

				if key == "b"
					@tree.move_cursor :pages, -1
				end

				if key == "h" or key == "a"
					if sel = @tree.selection.selected
						@tree.scroll_to_cell \
							sel.path \
							,(@tree.get_column 0) \
							,false \
							,0.0 \
							,0.0
					end
				end

				if key == "l" or key == "e"
					if sel = @tree.selection.selected
						@tree.scroll_to_cell \
							sel.path \
							,(@tree.get_column 5) \
							,false \
							,0.0 \
							,0.0
					end
				end

				if key == "o"
					if (ret = Actions.open @store, @tree, @settings, self)
						@db = ret
					end
				end

				if key == "i"
					Actions.insert 	@db ,@store, @tree, @settings.s
				end

				if key == "y"
					filter_box.each do |item|
						if item.class == Gtk::Entry
							item.grab_focus	
							break
						end
					end
				end

				if key == "t"
					Actions.edit 	@db ,@store, @tree, @settings.s
				end

				if key == "d"
					Actions.delete 	@db ,@store, @tree, @settings.s
				end

				if key == "s"
					Actions.settings @settings, @db, @store, @tree
				end

				cursor, column 		= @tree.cursor
				@tree.set_cursor 	cursor, nil, false
			end
		end

		add 			vbox
		show_all
	end

	def make_menu
		file_item 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::FILE
		file_item.image 		= nil
		file_open 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::OPEN
		file_import 			= Gtk::MenuItem.new "_Import"
		file_import.use_underline 	= true
		file_exit 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::QUIT

		file_menu 			= Gtk::Menu.new
		file_item.set_submenu 		file_menu
		file_menu.append 		file_open
		file_menu.append 		file_import
		file_menu.append 		file_exit

		edit_item 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::EDIT
		edit_item.image 		= nil
		edit_fetch_db	 		= Gtk::MenuItem.new "_Fetch database"
		edit_fetch_db.use_underline 	= true
		edit_fetch_fv	 		= Gtk::MenuItem.new "Fetch fa_vicons"
		edit_fetch_fv.use_underline 	= true
		edit_copy	 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::COPY
		edit_insert	 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::ADD
		edit_edit	 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::EDIT
		edit_delete	 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::DELETE
		edit_preferences 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::PREFERENCES

		edit_menu 			= Gtk::Menu.new
		edit_item.set_submenu 		edit_menu
		edit_menu.append 		edit_copy
		edit_menu.append 		edit_insert
		edit_menu.append 		edit_edit
		edit_menu.append 		edit_delete
		edit_menu.append 		edit_fetch_db
		edit_menu.append 		edit_fetch_fv
		edit_menu.append 		edit_preferences

		help_item 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::HELP
		help_item.image 		= nil
		help_doc 			= Gtk::MenuItem.new "_Doc"
		help_doc.use_underline 		= true
		help_about 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::ABOUT

		help_menu 			= Gtk::Menu.new 
		help_item.set_submenu 		help_menu
		help_menu.append		help_doc
		help_menu.append		help_about

		file_open.signal_connect "activate" do
			if (ret = Actions.open @store, @tree, @settings, self)
				@db = ret
			end
		end

		file_import.signal_connect "activate" do
			Actions.import 		@db, self
			Actions.store_feed 	@db, @store, @tree
		end

		file_exit.signal_connect "activate" do
			Gtk.main_quit
		end

		edit_fetch_db.signal_connect "activate" do
			Actions.store_feed 	@db, @store, @tree
		end

		edit_fetch_fv.signal_connect "activate" do
			r = @db.fetch nil

			for i in r do
				if i[2][/(http|https)/]
					uri  = URI i[2]
					path = "#{@settings.s['dir']}/favicon/#{uri.host}"

					if !Web_Data.favicon_exist? path
						if (icon = Web_Data.favicon_fetch i[2])
							Web_Data.favicon_write path, icon
						end
					end
				end
			end

			Actions.store_feed 	@db, @store, @tree
		end

		edit_copy.signal_connect "activate" do
			Actions.clipboard 	@store, @tree, @settings['xclip']
		end

		edit_insert.signal_connect "activate" do
			Actions.insert 		@db, @store, @tree, @settings.s
		end

		edit_delete.signal_connect "activate" do
			Actions.delete 		@db, @store, @tree, @settings.s
		end

		edit_edit.signal_connect "activate" do
			Actions.edit 		@db, @store, @tree, @settings.s
		end

		edit_preferences.signal_connect "activate" do
			Actions.settings 	@settings, @db, @store, @tree
		end

		help_about.signal_connect "activate" do
			about 			= Gtk::AboutDialog.new
			about.name 		= "poor man's bookmark"
			about.program_name 	= "pmb"
			about.version  		= "0.1"
			about.license		= "GNU GPL 2.0"
			about.website 		= "https://github.com/neoncortex/poor-man-s-bookmark"
			
			about.run
			about.destroy
		end

		menu_items = Hash[ \
			"file" => file_item \
			,"edit" => edit_item \
			,"help" => help_item]
	end

	def make_menubar items
		menu_bar = Gtk::MenuBar.new
		menu_bar.append 	items['file']
		menu_bar.append 	items['edit']
		#menu_bar.append 	items['help']
		menu_bar
	end

	def make_tree_menu items
		menu 			= Gtk::Menu.new
		menu.append 		items['file']
		menu.append 		items['edit']
		#menu.append 		items['help']
		menu.show_all
		menu
	end

	def make_tree 
		tree			= Tree.new @store
		tree.load_settings	@settings.s

		tree.insert_column 	0, "tag" \
						,tree.render_tag, {:text => 4}

		tree.insert_column 	1, "id" \
						,tree.render_id, {:text => 0}

		tree.insert_column 	2, "ico" \
						,Gtk::CellRendererPixbuf.new, {:pixbuf => 2}

		tree.insert_column 	3, "name" \
						,tree.render_name, {:text => 1}

		tree.insert_column 	4, "url" \
						,tree.render_url, {:text => 3}

		tree.insert_column 	5, "comment" \
						,tree.render_comment, {:text => 5}

		tree.search_column 	= @settings.s['search_column'].to_i

		tree.signal_connect "row-activated" do |tree, path, col|
			if tree.row_expanded? path
				tree.collapse_row path
			else
				tree.expand_row path, nil
			end

			Actions.clipboard @store, @tree, @settings.s['xclip']
		end

		menu		= make_tree_menu make_menu

		tree.signal_connect "button-press-event" do |tree, e|
			if e.kind_of? Gdk::EventButton and e.button == 3
				menu.popup nil, nil, e.button, e.time
			end
		end

		tree.signal_connect "popup_menu" do
			menu.popup nil, nil, 0, Gdk::Event::CURRENT_TIME
		end

		tree
	end

	def make_filter_box
		filter_label 			= Gtk::Label.new " Filter "
		filter_entry 			= Gtk::Entry.new
		filter_button 			= Gtk::Button.new :stock_id => Gtk::Stock::APPLY

		if (icon = Actions.search_icon "edit-find-symbolic")
			filter_entry.primary_icon_pixbuf = icon
			filter_entry.primary_icon_activatable = false
		end

		filter_button.signal_connect "clicked" do
			@store.filter 		= filter_entry.text
			Actions.store_feed 	@db, @store, @tree
		end

		filter_entry.signal_connect "activate" do
			@store.filter 		= filter_entry.text
			Actions.store_feed 	@db, @store, @tree
		end

		filter_box 			= Gtk::Box.new :horizontal, 2
		filter_box.pack_start 		filter_label \
							,:expand 	=> false \
							,:fill 		=> false

		filter_box.pack_start 		filter_entry \
							,:expand 	=> true \
							,:fill 		=> true 

		filter_box.pack_start 		filter_button \
							,:expand 	=> false \
							,:fill 		=> false

		filter_box
	end
end

Gtk.init
Gtk_Ui.new
Gtk.main

