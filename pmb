#!/usr/bin/env ruby

require 'fileutils'
require 'webkit-gtk'
require 'net/http'
require 'nokogiri'
require 'sqlite3'

class Db
	def initialize path
		begin
			@db = SQLite3::Database.open path
		rescue
			puts 		"can't open database"
			exit
		end

		@db.execute 	"CREATE TABLE IF NOT EXISTS bookmark" \
					"(id INTEGER PRIMARY KEY" \
					",name text" \
					",url text" \
					",comment text" \
					",tag text" \
					",UNIQUE(url))"
	end

	def insert data
		stm 		= @db.prepare "INSERT INTO bookmark " \
					"(name, url, comment, tag) VALUES(?,?,?,?)"
	
		stm.bind_param 	1, data[0]
		stm.bind_param 	2, data[1]
		stm.bind_param 	3, data[2]
		stm.bind_param 	4, data[3]

		begin
			rs 		= stm.execute
		rescue
			Actions.error "url already exists", false
		end
	end

	def import data
		stm 		= @db.prepare "INSERT OR IGNORE INTO bookmark " \
					"(name, url, comment, tag) VALUES(?,?,?,?)"
	
		stm.bind_param 	1, data[0]
		stm.bind_param 	2, data[1]
		stm.bind_param 	3, data[2]
		stm.bind_param 	4, data[3]
	end

	def delete id
		stm 		= @db.prepare "DELETE FROM bookmark " \
					"WHERE id = ?"	

		stm.bind_param	1, id
		rs 		= stm.execute
	end

	def delete_tag tag
		stm 		= @db.prepare "DELETE FROM bookmark " \
					"WHERE tag = ?"

		stm.bind_param 	1, tag
		rs 		= stm.execute
	end

	def edit id, field, value
		if field == "name" \
		or field == "url" \
		or field == "comment" \
		or field == "tag"
			stm 		= @db.prepare "UPDATE bookmark " \
						"SET #{field} = ? WHERE id = ?"

			stm.bind_param 	1, value
			stm.bind_param 	2, id
			rs 		= stm.execute
		end
	end

	def edit_tag tag, new_tag
		stm 		= @db.prepare "UPDATE bookmark " \
					"SET tag = ? WHERE tag = ?"

		stm.bind_param 	1, new_tag
		stm.bind_param 	2, tag
		rs 		= stm.execute
	end

	def find id
		stm 		= @db.prepare "SELECT * FROM bookmark " \
					"WHERE id = ? ORDER BY tag ASC"

		stm.bind_param 	1, id
		rs		= stm.execute
	end

	def fetch filter
		if filter
			stm 	= @db.prepare "SELECT * FROM bookmark " \
					"WHERE name LIKE '%%#{filter}%%' " \
					"OR url LIKE '%%#{filter}%%' " \
					"OR comment LIKE '%%#{filter}%%' " \
					"OR tag LIKE '%%#{filter}%%' " \
					"ORDER BY tag ASC"
		else
			stm 	= @db.prepare "SELECT * from bookmark " \
					"ORDER BY tag ASC"
		end

		rs 		= stm.execute
	end
end

class Settings
	def initialize
		@s = Hash[ \
			"dir" 			=> "#{ENV['HOME']}/.config/" \
							"pmb" \
			,"config" 		=> "config" \
			,"db" 			=> "#{ENV['HOME']}/.config/" \
							"pmb/bookmarks.db" \
			,"id_fg" 		=> String.new \
			,"id_bg" 		=> String.new \
			,"id_font" 		=> String.new \
			,"name_fg" 		=> String.new \
			,"name_bg" 		=> String.new \
			,"name_font" 		=> String.new \
			,"url_fg" 		=> String.new \
			,"url_bg" 		=> String.new \
			,"url_font" 		=> String.new \
			,"comment_fg" 		=> String.new \
			,"comment_bg"		=> String.new \
			,"comment_font"		=> String.new \
			,"tag_fg" 		=> String.new \
			,"tag_bg" 		=> String.new \
			,"tag_font" 		=> String.new \
			,"style"		=> "0" \
			,"search_column" 	=> "1" \
			,"xclip" 		=> "true" \
			,"tree_lines" 		=> "true" \
			,"auto_favicon" 	=> "true" \
			,"user_agent"		=> "Mozilla/5.0 (X11; Linux i686; rv:45.0) Gecko/20100101 Firefox/45.0"]

		if !(File.exists? "#{@s['dir']}")
			Dir.mkdir "#{@s['dir']}"
		end

		if !(File.exists? "#{@s['dir']}/favicon")
			Dir.mkdir "#{@s['dir']}/favicon"
		end

		if !(File.exists? "#{@s['dir']}/#{@s['config']}")
			save_config
		else
			load_config
		end
	end

	def save_config
		File.open("#{@s['dir']}/#{@s['config']}", "w") do |f|
			f.write "#DO NOT EDIT BY HAND\n\n"

			@s.each do |i|
				f.write "#{i[0]} = #{i[1]}\n"
			end
		end
	end

	def load_config
		File.open("#{@s['dir']}/#{@s['config']}", "r") do |f|
			while l = f.gets do
				if @s[l[/(^.*?\s)/][0...-1]]
					@s[l[/(^.*?\s)/][0...-1]] = l[/(?<==\s).*/]
				end
			end
		end
	end

	attr_accessor :s
end

class Web_Data
	def self.favicon_exist? url, s
		uri  		= URI url
		path 		= "#{s['dir']}/favicon/#{uri.host}#{uri.path}"

		if (File.exists? "#{path}/icon")
			return true
		end

		nil
	end

	def self.favicon_fetch uri, path, file
		begin 
			http 	= Net::HTTP.start uri.host \
					,:read_timeout 	=> 0.500 \
					,:use_https 	=> uri.scheme == 'https'

			icon 	= http.get file

			if icon.message == "Redirect" \
			or icon.message == "Moved Permanently" \
			or icon.message == "Moved Temporarily" 
				icon = (Net::HTTP.get (URI icon['location']))

				if !is_image? icon
					icon = (Net::HTTP.get (URI file))
				end

				if !is_image? icon
					icon = (Net::HTTP.get \
						(URI "#{uri.scheme}://#{uri.host}/favicon.ico"))

					favicon_write path, icon
				end

				favicon_write path, icon
			elsif icon.message == "Not Found"
				nil
			else
				favicon_write path, icon.body
			end
		rescue Exception => e #ugly, anyway ..
			nil
		end
	end

	def self.webkit_favicon_fetch url, store, tree, s
		uri  		= URI url
		path 		= "#{s['dir']}/favicon/#{uri.host}#{uri.path}"
		view 		= WebKitGtk::WebView.new

		view.settings.enable_scripts = false
		view.settings.enable_plugins = false
		view.settings.auto_shrink_images = true
		view.settings.enable_offline_web_application_cache = false
		view.settings.enable_display_of_insecure_content = false
		view.settings.enable_running_of_insecure_content = false
		view.settings.enable_dom_paste = false
		view.settings.enable_java_applet = false
		view.settings.enable_page_cache = false
		view.settings.enable_html5_database = false
		view.settings.enable_html5_local_storage = false
		view.settings.enable_media_stream = false
		view.settings.enable_webgl = false
		view.settings.enable_webaudio = false
		view.settings.enable_mediasource = false
		view.settings.user_agent = s['user_agent']	

		view.load_uri 	url
		
		view.signal_connect "icon-loaded" do
			if (f = view.try_get_favicon_pixbuf 20, 20)
				if !(File.exists? path)
					FileUtils.mkdir_p path
				end

				f.save "#{path}/icon", "png", nil

				tree.model.each do |model, tpath, iter|
					if (store.get_value iter, 3) == url
						store.set_value iter, 2, f 
					end
				end
			else
				favicon_fetch uri, path, view.icon_uri

				tree.model.each do |model, tpath, iter|
					if (store.get_value iter, 3) == url \
					and (File.exist? "#{path}/icon")
						store.set_value iter, 2, (Gdk::Pixbuf.new \
							"#{path}/icon", 20, 20)
					end
				end		
			end

			view 		= nil
		end
	end

	def self.is_svg? icon
		doc 		= Nokogiri icon
		svg	 	= doc.css "svg"

		for i in svg do
			if i['version'] == "1.1" \
			and i['xmlns'] == "http://www.w3.org/2000/svg"
				return true
			end
		end

		nil
	end

	def self.is_image? icon
		png 	= Regexp.new("\x89PNG".force_encoding("binary"))
		jpg 	= Regexp.new("\xff\xd8\xff\xe0\x00\x10JFIF".force_encoding("binary"))
		jpg2	= Regexp.new("\xff\xd8\xff\xe1(.*){2}Exif".force_encoding("binary"))

		if icon[0,4] == "\x00\x00\x01\x00" \
		or icon[0,2] == "\x42\x4d" \
		or icon[/^#{png}/] \
		or icon[/^#{jpg}/] \
		or icon[/^#{jpg2}/]
			return true
		end

		nil
	end

	def self.favicon_write path, icon
		if is_image? icon
			if !(File.exists? path)
				FileUtils.mkdir_p path
			end

			File.open("#{path}/icon", "wb") do |f|
				f.write icon
			end
		end
	end
end

class Actions
	def self.clipboard store, tree, xclip
		url 	= store.get_value \
				(tree.model.get_iter tree.selection.selected_rows[0]), 3

		if xclip == "true"
			Process.detach spawn \
				"echo -n '#{url}' | xclip -i -selection 'primary'"

			Process.detach spawn \
				"echo -n '#{url}' | xclip -i -selection 'secoundary'"

			Process.detach spawn \
				"echo -n '#{url}' | xclip -i -selection 'clipboard'"
		else
			clip_p 		= Gtk::Clipboard.get Gdk::Selection::PRIMARY
			clip_c 		= Gtk::Clipboard.get Gdk::Selection::CLIPBOARD

			clip_p.text 	= url
			clip_c.text 	= url

			clip_p.store
			clip_c.store
		end
	end

	def self.store_feed db, store, tree
		store.clear
		
		if store.style.to_i == 0
			store.feed_tree		(db.fetch store.filter)
		else
			store.feed_tag		(db.fetch store.filter)
		end

		tree.expand_all

		if tree.selected_row \
		and (tree.model.get_iter tree.selected_row)
			tree.set_cursor 	tree.selected_row, nil, false
			#tree.scroll_to_cell 	tree.selected_row, nil, true, 0.5, 0.0
		end
	end

	def self.open store, tree, settings, window
		chooser = Gtk::FileChooserDialog.new \
			:title 		=> "Open" \
			,:parent 	=> window \
			,:action 	=> :save \
			,:buttons 	=> [ \
				[Gtk::Stock::CANCEL, :cancel] \
				,[Gtk::Stock::OPEN, :accept]]

		db 	= nil

		if chooser.run == Gtk::ResponseType::ACCEPT
			begin
				db 			= Db.new chooser.filename
				settings.s['db'] 	= chooser.filename
				chooser.destroy

				Actions.store_feed 	db, store, tree
				settings.save_config
			rescue
				chooser.destroy
				Actions.error 		"Error opening file", false
			end
		else
			chooser.destroy
		end

		if db
			db
		end
	end

	def self.import db_ex, window
		chooser = Gtk::FileChooserDialog.new \
			:title 		=> "Open" \
			,:parent 	=> window \
			,:action 	=> :open \
			,:buttons 	=> [ \
				[Gtk::Stock::CANCEL, :cancel] \
				,[Gtk::Stock::OPEN, :accept]]

		if chooser.run == Gtk::ResponseType::ACCEPT
			begin
				db 	= Db.new chooser.filename
				r 	= db.fetch nil

				for i in r do
					db_ex.import [i[1], i[2], i[3], i[4]]
				end

				chooser.destroy
			rescue
				chooser.destroy
				Actions.error 	"Error importing file", false
			end
		else
			chooser.destroy
		end
	end

	def self.insert db, store, tree, s
		Gtk_Insert.new 		db, store, tree, s
	end

	def self.edit db, store, tree, s
		if tree.model.iter_first
			tree.selected_row 	= tree.selection.selected_rows[0]
			Gtk_Edit.new 		db, store, tree, s
		else
			error "Nothing to edit.", false
		end
	end

	def self.delete db, store, tree, s
		if tree.model.iter_first
			tree.selected_row 	= tree.selection.selected_rows[0]
			Gtk_Delete.new 		db, store, tree, s
		else
			error "Nothing to delete.", false
		end
	end

	def self.download_favicon store, tree, s
		if tree.selection
			url 	= store.get_value \
					(tree.model.get_iter tree.selection.selected_rows[0]), 3

			Web_Data.webkit_favicon_fetch url, store, tree, s
		end
	end

	def self.error message, fatal
		Gtk_Error.new 		message, fatal
	end

	def self.settings settings, db, store, tree
		tree.selected_row 	= tree.selection.selected_rows[0]
		Gtk_Settings.new 	settings, db, store, tree
	end

	def self.search_icon icon
		icon_theme 	= Gtk::IconTheme.default

		if icon_theme.has_icon? icon
			r = icon_theme.load_icon icon \
				,16, Gtk::IconTheme::LookupFlags::FORCE_SIZE
			return r
		end

		nil
	end

	def self.set_icon url, alt, s
		if url and url[/^(http|https)/]
			if (Web_Data.favicon_exist? url, s)
				begin
					uri  	= URI url
					path 	= "#{s['dir']}/favicon/#{uri.host}#{uri.path}"
					icon 	= Gdk::Pixbuf.new "#{path}/icon", 20, 20
				rescue
					icon = Actions.search_icon alt
				end
			else
				icon = Actions.search_icon alt
			end
		
			return icon
		else
			return (Actions.search_icon alt)
		end
	end
end

class Store < Gtk::TreeStore
	attr_accessor :filter, :style

	def initialize *args
		super(*args[1..-1])
		@s		= args[0]
		@style 		= @s['style'].to_i
	end

	def search_toplevel entry
		each do |s, tp, it|
			if it \
			and entry \
			and entry == (get_value it, 4) \
			and !it.parent
				return it
			end
		end

		false
	end

	def search_children entry, parent
		each do |s, tp, it|
			if it \
			and entry \
			and entry == (get_value it, 4) \
			and it.parent \
			and parent == (get_value it.parent, 4) 
				return it
			end
		end

		false
	end

	def get_iter_root iter
		parent = iter.parent
		
		if !parent
			return iter
		end

		if parent and parent.parent
			get_iter_root parent
		elsif parent and !parent.parent
			return parent
		end
	end

	def insert_dir iter, name, tag, number_of_items
		it = insert iter, number_of_items += 1 \
			,["", "", nil, "", "#{name}", "", "#{tag}"]

		it
	end

	def feed_tree result
		number_of_items = 0
		root		= nil

		for i in result do
			dirs 	= i[4].split '/'
			iter 	= nil

			dirs.each_with_index do |d, j|
				if j == 0
					if !(iter = search_toplevel d)
						iter = insert_dir nil, d, i[4] \
							,number_of_items
					
						root = iter
					else
						root = iter
					end
				else
					if dirs[j - 1] 
						if !(r = search_children d, dirs[j - 1]) 
							if dirs[j]
								iter = insert_dir iter, d, i[4] \
									,number_of_items
							end
						else
							if !root == (get_iter_root r)
								iter = insert_dir iter, d, i[4] \
									,number_of_items
							else
								iter = r
							end
						end
					end
				end
			end

			insert iter, number_of_items += 1 \
				,["#{i[0]}" \
				,"#{i[1]}" \
				,(Actions.set_icon i[2], "starred-symbolic", @s) \
				,"#{i[2]}" \
				,"-" \
				,"#{i[3]}" \
				,"#{i[4]}"]

			icon = nil
		end
	end

	def feed_tag result
		last 			= nil
		number_of_items 	= 0

		for i in result do
			if !last or i[4] != last
				iter = insert_dir nil, i[4], i[4], number_of_items
			end

			insert iter, number_of_items += 1 \
				,["#{i[0]}" \
				,"#{i[1]}" \
				,(Actions.set_icon i[2], "starred-symbolic", @s) \
				,"#{i[2]}" \
				,"" \
				,"#{i[3]}" \
				,"#{i[4]}"]

			last	= i[4]
			icon	= nil
		end
	end
end

class Tree < Gtk::TreeView
	def initialize store
		super store
		@render_id 		= Gtk::CellRendererText.new
		@render_name		= Gtk::CellRendererText.new
		@render_url 		= Gtk::CellRendererText.new
		@render_comment		= Gtk::CellRendererText.new
		@render_tag 		= Gtk::CellRendererText.new
		@selected_row 		= nil
	end

	def parse_color render, color_fg, color_bg
		if !color_fg.empty?
			render.foreground_gdk 	= Gdk::Color.parse color_fg
		else
			render.foreground 	= nil
		end

		if !color_bg.empty?
			render.background_gdk 	= Gdk::Color.parse color_bg
		else
			render.background 	= nil
		end
	end

	def parse_font render, font
		if !font.empty?
			render.font 	= font
		else
			render.font 	= nil
		end
	end

	def load_settings s
		parse_color 	@render_id, s['id_fg'], s['id_bg']
		parse_color 	@render_name, s['name_fg'], s['name_bg']
		parse_color 	@render_url, s['url_fg'], s['url_bg']
		parse_color 	@render_comment, s['comment_fg'], s['comment_bg']
		parse_color 	@render_tag, s['tag_fg'], s['tag_bg']

		parse_font 	@render_id, s['id_font']
		parse_font 	@render_name, s['name_font']
		parse_font 	@render_url, s['url_font']
		parse_font 	@render_comment, s['comment_font']
		parse_font 	@render_tag, s['tag_font']

		if s['tree_lines'] == "true"
			self.enable_tree_lines  = true
		else
			self.enable_tree_lines  = false
		end

		columns_autosize
		self.search_column	= s['search_column'].to_i
	end

	attr_reader \
		:render_id \
		,:render_name \
		,:render_url \
		,:render_comment \
		,:render_tag 

	attr_accessor :tree_lines, :selected_row
end

class Grid < Gtk::Grid
	def initialize
		super
		set_property 	"row-homogeneous"	,true
		set_property 	"column-homogeneous"	,true
	end
end

class Gtk_Window < Gtk::Window
	def initialize 
		super
		set_wmclass 	"Poor man's bookmark"	,"Pmb"
		set_title 	"Poor man's bookmark"
		set_type_hint 	:dialog
		set_default_size 600, 0
		signal_connect "destroy" do
			destroy
		end
	end

	def create_name_entry text
		name_entry 		= Gtk::Entry.new

		if (icon = Actions.search_icon "insert-text-symbolic")
			name_entry.primary_icon_pixbuf = icon
			name_entry.primary_icon_activatable = false
		end

		if text
			name_entry.set_text text
		end

		name_entry
	end

	def create_url_entry text, favicon, s, tree, store
		url_entry 		= Gtk::Entry.new

		url_entry.primary_icon_pixbuf = favicon

		if text
			url_entry.set_text text
		end

		url_entry.signal_connect "icon-press" do
			if url_entry.text and url_entry.text[/(http|https)/]
				Actions.download_favicon store, tree, s
			end
		end

		url_entry.primary_icon_activatable = true
		url_entry
	end

	def create_comment_entry text
		comment_entry 		= Gtk::Entry.new

		if (icon = Actions.search_icon "insert-text-symbolic")
			comment_entry.primary_icon_pixbuf = icon
			comment_entry.primary_icon_activatable = false
		end

		if text
			comment_entry.set_text text
		end

		comment_entry
	end

	def create_tag_entry text
		tag_entry 		= Gtk::Entry.new

		if (icon = Actions.search_icon "insert-text-symbolic")
			tag_entry.primary_icon_pixbuf = icon
			tag_entry.primary_icon_activatable = false
		end

		if text
			tag_entry.set_text text
		end

		tag_entry
	end
end

class Gtk_Error < Gtk_Window
	def initialize message, fatal
		super()
		set_title 		title + " - Error"

		error_label 		= Gtk::Label.new 
		error_label.set_markup	"<span foreground='red' " \
						"font-weight='heavy' " \
						"size='large'>" \
						"Error \n" \
						"</span>"

		error 			= Gtk::Label.new message
		close_button 		= Gtk::Button.new :stock_id => Gtk::Stock::CLOSE

		close_button.signal_connect "clicked" do
			if fatal
				Gtk.main_quit
			else
				destroy
			end
		end

		grid 				= Grid.new

						#e   #t   #l    #a
		grid.attach error_label, 	0,   0,   20,   1
		grid.attach error, 		0,   1,   20,   1
		grid.attach close_button, 	0,   2,   20,   1

		vbox 				= Gtk::Box.new :vertical, 2
		vbox.pack_start 		grid \
							,:expand => false \
							,:fill => false \
							,:padding => 0 \

		add 				vbox
		show_all
	end
end

class Gtk_Insert < Gtk_Window
	def initialize db, store, tree, s
		super()
		set_title 		title + " - Insert"

		name_entry 		= create_name_entry nil
		url_entry 		= create_url_entry nil, (Actions.set_icon nil \
						,"non-starred-symbolic", s), s, tree, store
		comment_entry 		= create_comment_entry nil
		tag_entry 		= create_tag_entry nil
		row 			= tree.selection.selected_rows[0]

		insert_button 		= Gtk::Button.new :stock_id => Gtk::Stock::ADD
		cancel_button 		= Gtk::Button.new :stock_id => Gtk::Stock::CANCEL

		url_entry.primary_icon_activatable = false

		if tree.model.iter_first \
		and !(tag = store.get_value (tree.model.get_iter row), 6).empty?
			tag_entry.set_text tag
		end 

		insert_button.signal_connect "clicked" do
			if (name_entry.text).size > 0 and (url_entry.text).size > 0
				name		= name_entry.text
				url 		= url_entry.text

				if (comment_entry.text).size == 0
					comment 	= "none"
				else
					comment 	= comment_entry.text
				end

				if (tag_entry.text).size == 0
					tag 		= "none"
				else
					tag 		= tag_entry.text
				end

				db.insert 		[name, url, comment, tag]
				Actions.store_feed 	db, store, tree

				tree.model.each do |model, tpath, iter|
					if (store.get_value iter, 3) == url
						tree.set_cursor tpath, nil, false

						if s['auto_favicon'] == "true" \
						and !(Web_Data.favicon_exist? url, s)
							Actions.download_favicon \
								store, tree, s
						end
					end
				end		

				destroy
			else
				Actions.error "Need at least name and url", false
			end
		end

		cancel_button.signal_connect "clicked" do
			destroy
		end

		grid 			= Grid.new

								#e   #t   #l    #a
		grid.attach (Gtk::Label.new "Name"), 		0,   0,   20,   1
		grid.attach name_entry, 			20,  0,   20,   1
		grid.attach (Gtk::Label.new "Url"), 		0,   1,   20,   1
		grid.attach url_entry,				20,  1,   20,   1
		grid.attach (Gtk::Label.new "Comment"),		0,   2,   20,   1
		grid.attach comment_entry,			20,  2,   20,   1
		grid.attach (Gtk::Label.new "Tag"), 		0,   3,   20,   1
		grid.attach tag_entry,				20,  3,   20,   1
		grid.attach insert_button,			0,   4,   20,   1
		grid.attach cancel_button,			20,  4,   20,   1

		vbox 			= Gtk::Box.new :vertical, 2
		vbox.pack_start 	grid \
						,:expand 	=> false \
						,:fill 		=> false \
						,:padding 	=> 0 \

		add 			vbox
		show_all
	end
end

class Gtk_Edit < Gtk_Window
	def initialize db, store, tree, s
		super()
		set_title 		title + " - Edit"

		edit_button 		= Gtk::Button.new :stock_id => Gtk::Stock::APPLY
		cancel_button 		= Gtk::Button.new :stock_id => Gtk::Stock::CANCEL
		grid 			= Grid.new
		rows			= tree.selection.selected_rows
		
		cancel_button.signal_connect "clicked" do
			destroy
		end

		if rows.size > 1
			set_title 	title + " - Edit multiple tags"
			tag_entry 	= create_name_entry nil

								#e   #t   #l    #a
			grid.attach (Gtk::Label.new "Tag"),	0,   1,   20,   1
			grid.attach tag_entry, 			20,  1,   20,   1
			grid.attach edit_button,		0,   2,   20,   1
			grid.attach cancel_button,		20,  2,   20,   1

			edit_button.signal_connect "clicked" do
				for i in rows do
					id 		= store.get_value (tree.model.get_iter i), 0
					db.edit id	,"tag", tag_entry.text
				end

				Actions.store_feed 	db, store, tree
				destroy
			end
			
			vbox 		= Gtk::Box.new :vertical, 2

			vbox.pack_start grid \
					,:expand 	=> false \
					,:fill 		=> false \
					,:padding 	=> 0 \

			add 		vbox	
		else
			row			= rows[0]
			id 			= store.get_value (tree.model.get_iter row), 0
			name 			= store.get_value (tree.model.get_iter row), 1
			url  			= store.get_value (tree.model.get_iter row), 3
			comment 		= store.get_value (tree.model.get_iter row), 5
			tag 			= store.get_value (tree.model.get_iter row), 6

			tag_entry 		= create_tag_entry tag

			if url.empty?
				set_title 	title + " - Edit tag"
				old_tag 	= store.get_value (tree.model.get_iter row), 6

				tag_entry.set_text old_tag

				tag_entry.signal_connect "activate" do
					db.edit_tag 		old_tag, tag_entry.text
					Actions.store_feed 	db, store, tree
					destroy
				end
				
				edit_button.signal_connect "clicked" do
					db.edit_tag 		old_tag, tag_entry.text
					Actions.store_feed 	db, store, tree
					destroy
				end
									#e   #t   #l    #a
				grid.attach (Gtk::Label.new "Tag"),	0,   1,   20,   1
				grid.attach tag_entry, 			20,  1,   20,   1
				grid.attach edit_button,		0,   2,   20,   1
				grid.attach cancel_button,		20,  2,   20,   1

			else
				name_entry 	= create_name_entry name
				url_entry 	= create_url_entry url, (Actions.set_icon url \
							,"starred-symbolic", s), s, tree, store
				comment_entry 	= create_comment_entry comment

				edit_button.signal_connect "clicked" do
					if name != name_entry.text 
						db.edit id, "name", name_entry.text
					end

					if url != url_entry.text 
						db.edit id, "url", url_entry.text
					end

					if comment != comment_entry.text 
						db.edit id, "comment", comment_entry.text
					end

					if tag != tag_entry.text
						db.edit id, "tag", tag_entry.text
					end

					Actions.store_feed 	db, store, tree

					if url != url_entry.text 
						tree.model.each do |model, tpath, iter|
							if (store.get_value iter, 3) == url_entry.text
								tree.set_cursor tpath, nil, false

								if s['auto_favicon'] == "true" \
								and !(Web_Data.favicon_exist? \
									url_entry.text, s)
									Actions.download_favicon \
										store, tree, s
								end
							end
						end		
					end

					destroy
				end

									#e   #t   #l    #a
				grid.attach (Gtk::Label.new "Name"),	0,   1,   20,   1
				grid.attach name_entry, 		20,  1,   20,   1
				grid.attach (Gtk::Label.new "Url"), 	0,   2,   20,   1
				grid.attach url_entry,			20,  2,   20,   1
				grid.attach (Gtk::Label.new "Comment"),	0,   3,   20,   1
				grid.attach comment_entry,		20,  3,   20,   1
				grid.attach (Gtk::Label.new "Tag"), 	0,   4,   20,   1
				grid.attach tag_entry,			20,  4,   20,   1
				grid.attach edit_button,		0,   5,   20,   1
				grid.attach cancel_button,		20,  5,   20,   1
			end

			vbox 			= Gtk::Box.new :vertical, 2
			vbox.pack_start 	grid \
							,:expand 	=> false \
							,:fill 		=> false \
							,:padding 	=> 0 \

			add 			vbox
		end

		show_all
	end
end

class Gtk_Delete < Gtk_Window
	def initialize db, store, tree, s
		super()
		set_title 		title + " - Delete"

		delete_button 		= Gtk::Button.new :stock_id => Gtk::Stock::DELETE
		cancel_button 		= Gtk::Button.new :stock_id => Gtk::Stock::CANCEL
		grid 			= Grid.new
		rows			= tree.selection.selected_rows

		cancel_button.signal_connect "clicked" do
			destroy
		end

		if rows.size > 1
			set_title 	title + " - Delete multiple"
			vbox 		= Gtk::Box.new :vertical, 2
			hbox 		= Gtk::Box.new :horizontal, 2
			
			vbox.pack_start	(Gtk::Label.new "delete bookmarks:")
			hbox.pack_start delete_button
			hbox.pack_start cancel_button
			
			rows.each_with_index do |t, i|
				id 		= store.get_value (tree.model.get_iter t), 0
				name 		= store.get_value (tree.model.get_iter t), 1
				url  		= store.get_value (tree.model.get_iter t), 3
				comment 	= store.get_value (tree.model.get_iter t), 5
				tag 		= store.get_value (tree.model.get_iter t), 6

				name_entry 		= create_name_entry name
				name_entry.set_editable false

				url_entry 		= create_url_entry url, (Actions.set_icon url \
								,"starred-symbolic", s), s, tree, store
				url_entry.set_editable 	false
				url_entry.primary_icon_activatable = false

				grid.attach name_entry,		0,  i,  20,   1
				grid.attach url_entry,		20, i,  20,   1
			end

			delete_button.signal_connect "clicked" do
				for i in rows do
					id 		= store.get_value (tree.model.get_iter i), 0
					db.delete 	id
				end

				Actions.store_feed 	db, store, tree
				destroy
			end
			
			vbox.pack_start grid \
					,:expand 	=> false \
					,:fill 		=> false \
					,:padding 	=> 0 \

			vbox.pack_start hbox \
					,:expand 	=> false \
					,:fill 		=> false \
					,:padding 	=> 0 \

			add 	vbox	
		else	
			row			= rows[0]
			id 			= store.get_value (tree.model.get_iter row), 0
			name 			= store.get_value (tree.model.get_iter row), 1
			url  			= store.get_value (tree.model.get_iter row), 3
			comment 		= store.get_value (tree.model.get_iter row), 5
			tag 			= store.get_value (tree.model.get_iter row), 6

			tag_entry 		= create_tag_entry tag
			tag_entry.set_editable 	false

			if url.empty?
				grid.attach (Gtk::Label.new "Tag"), 	0,   0,   20,   1
				grid.attach tag_entry, 			20,  0,   20,   1
				grid.attach delete_button,		0,   1,   20,   1
				grid.attach cancel_button,		20,  1,   20,   1
			else
				name_entry 		= create_name_entry name
				name_entry.set_editable false

				url_entry 		= create_url_entry url, (Actions.set_icon url \
								,"starred-symbolic", s), s, tree, store
				url_entry.set_editable 	false
				url_entry.primary_icon_activatable = false

				comment_entry 			= create_comment_entry comment
				comment_entry.set_editable 	false

				grid.attach (Gtk::Label.new "Name"), 	0,   0,   20,   1
				grid.attach name_entry, 		20,  0,   20,   1
				grid.attach (Gtk::Label.new "Url"), 	0,   1,   20,   1
				grid.attach url_entry,			20,  1,   20,   1
				grid.attach (Gtk::Label.new "Comment"),	0,   2,   20,   1
				grid.attach comment_entry,		20,  2,   20,   1
				grid.attach (Gtk::Label.new "Tag"), 	0,   3,   20,   1
				grid.attach tag_entry,			20,  3,   20,   1
				grid.attach delete_button,		0,   4,   20,   1
				grid.attach cancel_button,		20,  4,   20,   1
			end

			delete_button.signal_connect "clicked" do
				if url.empty?
					db.delete_tag 	tag
				else
					db.delete 	id
				end

				Actions.store_feed 	db, store, tree
				destroy
			end

			vbox 			= Gtk::Box.new :vertical, 2
			vbox.pack_start 	grid \
							,:expand 	=> false \
							,:fill 		=> false \
							,:padding 	=> 0 \

			add 			vbox
		end

		cancel_button.grab_focus
		show_all
	end
end

class Gtk_Settings < Gtk_Window
	def initialize settings, db, store, tree
		super()
		set_title 		title + " - Options"

		s 			= settings.s
		id_font_button 		= Gtk::FontButton.new s['id_font']
		name_font_button 	= Gtk::FontButton.new s['name_font']
		url_font_button 	= Gtk::FontButton.new s['url_font']
		comment_font_button 	= Gtk::FontButton.new s['comment_font']
		tag_font_button 	= Gtk::FontButton.new s['tag_font']

		color_buttons = [ \
			[(color_button s['id_fg'])	  ,String.new] \
			,[(color_button s['id_bg'])	  ,String.new] \
			,[(color_button s['name_fg'])	  ,String.new] \
			,[(color_button s['name_bg'])	  ,String.new] \
			,[(color_button s['url_fg'])	  ,String.new] \
			,[(color_button s['url_bg'])	  ,String.new] \
			,[(color_button s['comment_fg'])  ,String.new] \
			,[(color_button s['comment_bg'])  ,String.new] \
			,[(color_button s['tag_fg'])	  ,String.new] \
			,[(color_button s['tag_bg'])	  ,String.new]] 

		0.step(color_buttons.size - 1, 1) do |i|
			color_buttons[i][0].signal_connect "color-set" do
				color_buttons[i][1] = color_buttons[i][0].color.to_s
			end
		end

		tree_style		= Gtk::ComboBoxText.new 
		tree_style.insert_text 	0, "Tree"
		tree_style.insert_text 	1, "Tag"
		tree_style.set_active 	s['style'].to_i
		t_tree_style 		= s['style']

		tree_style.signal_connect "changed" do |s|
			t_tree_style = s.active
		end

		tree_lines 		= Gtk::CheckButton.new "Tree lines", false

		if s['tree_lines'] == "true"
			tree_lines.set_active	true
		else
			tree_lines.set_active	false
		end

		user_agent_entry	= Gtk::Entry.new
		user_agent_entry.text	= s['user_agent']

		xclip 			= Gtk::CheckButton.new "xclip?", false

		if s['xclip'] == "true"
			xclip.set_active	true
		else
			xclip.set_active	false
		end

		search_column			= Gtk::ComboBoxText.new 
		search_column.insert_text 	0, "id"
		search_column.insert_text 	1, "name"
		search_column.insert_text 	3, "url"
		search_column.insert_text 	5, "comment"
		search_column.insert_text 	6, "tag"
		search_column.set_active 	s['search_column'].to_i
		t_search_column 		= s['search_column']

		search_column.signal_connect "changed" do |s|
			t_search_column = s.active
		end

		auto_favicon 			= Gtk::CheckButton.new "auto download favicon?", false

		if s['auto_favicon'] == "true"
			auto_favicon.set_active	true
		else
			auto_favicon.set_active	false
		end

		apply_button 		= Gtk::Button.new :stock_id => Gtk::Stock::APPLY
		cancel_button 		= Gtk::Button.new :stock_id => Gtk::Stock::CANCEL

		ap_grid 		= Grid.new

								#e   #t   #l   #a
		ap_grid.attach (Gtk::Label.new "List:"),	0,   0,   5,   1
		ap_grid.attach tree_lines,			5,   0,   5,   1
		ap_grid.attach (tree_style),   			10,  0,   5,   1
		ap_grid.attach (Gtk::Label.new ""),   		0,   1,   5,   1
		ap_grid.attach (Gtk::Label.new "Column"),   	0,   2,   5,   1
		ap_grid.attach (Gtk::Label.new "Foreground"),   5,   2,   5,   1
		ap_grid.attach (Gtk::Label.new "Background"),   10,  2,   5,   1
		ap_grid.attach (Gtk::Label.new "Font"),     	15,  2,   5,   1
		ap_grid.attach (Gtk::Label.new "Id"),		0,   3,   5,   1
		ap_grid.attach color_buttons[0][0],		5,   3,   5,   1
		ap_grid.attach color_buttons[1][0],		10,  3,   5,   1
		ap_grid.attach id_font_button,			15,  3,   5,   1
		ap_grid.attach (Gtk::Label.new "Name"),		0,   4,   5,   1
		ap_grid.attach color_buttons[2][0],		5,   4,   5,   1
		ap_grid.attach color_buttons[3][0],		10,  4,   5,   1
		ap_grid.attach name_font_button,		15,  4,   5,   1
		ap_grid.attach (Gtk::Label.new "Url"), 		0,   5,   5,   1
		ap_grid.attach color_buttons[4][0],		5,   5,   5,   1
		ap_grid.attach color_buttons[5][0],		10,  5,   5,   1
		ap_grid.attach url_font_button,			15,  5,   5,   1
		ap_grid.attach (Gtk::Label.new "Comment"),	0,   6,   5,   1
		ap_grid.attach color_buttons[6][0],		5,   6,   5,   1
		ap_grid.attach color_buttons[7][0],		10,  6,   5,   1
		ap_grid.attach comment_font_button,		15,  6,   5,   1
		ap_grid.attach (Gtk::Label.new "Tag"), 		0,   7,   5,   1
		ap_grid.attach color_buttons[8][0],		5,   7,   5,   1
		ap_grid.attach color_buttons[9][0],		10,  7,   5,   1
		ap_grid.attach tag_font_button,			15,  7,   5,   1

		bh_grid			= Grid.new

		bh_grid.attach (Gtk::Label.new "Search column:"),	0,   0,   5,   1
		bh_grid.attach search_column,				5,   0,   5,   1
		bh_grid.attach (Gtk::Label.new "Clipboard:"),		0,   1,   5,   1
		bh_grid.attach xclip,					5,   1,   5,   1
		bh_grid.attach (Gtk::Label.new "Favicon:"),		0,   2,   5,   1
		bh_grid.attach auto_favicon,				5,   2,   5,   1
		bh_grid.attach (Gtk::Label.new "User agent:"),		0,   3,   5,   1
		bh_grid.attach user_agent_entry,			5,   3,   5,   1

		tabs			= Gtk::Notebook.new
		tabs.append_page 	bh_grid, (Gtk::Label.new "Options")
		tabs.append_page 	ap_grid, (Gtk::Label.new "Appearance")

		vbox 			= Gtk::Box.new :vertical, 2
		vbox.pack_start 	tabs \
						,:expand 	=> false \
						,:fill 		=> false \
						,:padding 	=> 0

		button_box 		= Gtk::Box.new :horizontal, 2
		button_box.pack_start 	apply_button 
		button_box.pack_start 	cancel_button 
		vbox.pack_start 	button_box \
						,:expand 	=> true \
						,:fill 		=> false \
						,:padding 	=> 0

		cancel_button.signal_connect "clicked" do
			destroy
		end

		apply_button.signal_connect "clicked" do
			s['id_fg'] 		= color_buttons[0][1] if !color_buttons[0][1].empty?
			s['id_bg'] 		= color_buttons[1][1] if !color_buttons[1][1].empty?
			s['name_fg'] 		= color_buttons[2][1] if !color_buttons[2][1].empty?
			s['name_bg'] 		= color_buttons[3][1] if !color_buttons[3][1].empty?
			s['url_fg'] 		= color_buttons[4][1] if !color_buttons[4][1].empty?
			s['url_bg'] 		= color_buttons[5][1] if !color_buttons[5][1].empty?
			s['comment_fg'] 	= color_buttons[6][1] if !color_buttons[6][1].empty?
			s['comemnt_bg'] 	= color_buttons[7][1] if !color_buttons[7][1].empty?
			s['tag_fg'] 		= color_buttons[8][1] if !color_buttons[8][1].empty?
			s['tag_bg'] 		= color_buttons[9][1] if !color_buttons[9][1].empty?

			s['style'] 		= t_tree_style

			if tree_lines.active?
				s['tree_lines'] = "true"
			else
				s['tree_lines'] = "false"
			end

			s['id_font'] 		= id_font_button.font_name
			s['name_font']    	= name_font_button.font_name
			s['url_font']     	= url_font_button.font_name
			s['comment_font'] 	= comment_font_button.font_name
			s['tag_font']     	= tag_font_button.font_name

			s['user_agent'] 	= user_agent_entry.text

			if xclip.active?
				s['xclip'] = "true"
			else
				s['xclip'] = "false"
			end

			s['search_column'] 	= t_search_column

			if auto_favicon.active?
				s['auto_favicon'] = "true"
			else
				s['auto_favicon'] = "false"
			end

			settings.save_config
			store.style 		= s['style'].to_i
			Actions.store_feed	db, store, tree
			tree.load_settings	s
			destroy
		end

		add 			vbox
		show_all
	end

	def color_button color
		button 			= Gtk::ColorButton.new 

		if !color.empty?
			button.color	= Gdk::Color.parse color 
		end

		button
	end
end

class Gtk_Ui < Gtk_Window
	def initialize 
		super
		set_default_size 	800, 600
		set_type_hint 		:normal

		signal_connect "destroy" do
			Gtk.main_quit
		end

		@settings 		= Settings.new
		@db 			= Db.new @settings.s['db']
		@store 			= Store.new @settings.s, String, String \
						,Gdk::Pixbuf, String, String, String, String
		@tree 			= make_tree 

		Actions.store_feed 	@db, @store, @tree

		sw 			= Gtk::ScrolledWindow.new nil, nil
		sw.border_width 	= 2
		sw.add 			@tree

		vbox 			= Gtk::Box.new :vertical, 2

		vbox.pack_start 	(make_menubar make_menu) \
						,:expand 	=> false \
						,:fill 		=> false

		vbox.pack_start 	sw 

		filter_box 		= make_filter_box
		vbox.pack_start 	filter_box \
						,:expand 	=> false \
						,:fill 		=> false

		if @tree.model.iter_first
			@tree.set_cursor (@tree.model.iter_first).path, nil, false
			@tree.grab_focus
		end

		signal_connect "key-press-event" do |w, e|
			key = "#{Gdk::Keyval.to_name e.keyval}"

			if key == "Escape"
				@tree.grab_focus
			end

			if e.state.control_mask?
				if key == "v" 
					@tree.expand_all
				end

				if key == "x"
					@tree.collapse_all
				end

				if key == "j" or key == "n"
					@tree.move_cursor :display_lines, 1 
				end

				if key == "k" or key == "p"
					@tree.move_cursor :display_lines, -1 
				end

				if key == "g"
					@tree.move_cursor :buffer_ends, -1
				end

				if key == "G"
					@tree.move_cursor :buffer_ends, 1
				end

				if key == "f"
					@tree.move_cursor :pages, 1
				end

				if key == "b"
					@tree.move_cursor :pages, -1
				end

				if key == "h" or key == "a"
					if sel = (@tree.model.get_iter @tree.selection.selected_rows[0])
						@tree.scroll_to_cell \
							sel.path \
							,(@tree.get_column 0) \
							,false \
							,0.0 \
							,0.0
					end
				end

				if key == "l" or key == "e"
					if sel = (@tree.model.get_iter @tree.selection.selected_rows[0])
						@tree.scroll_to_cell \
							sel.path \
							,(@tree.get_column 5) \
							,false \
							,0.0 \
							,0.0
					end
				end

				if key == "o"
					if (ret = Actions.open @store, @tree, @settings, self)
						@db = ret
					end
				end

				if key == "i"
					Actions.insert 	@db ,@store, @tree, @settings.s
				end

				if key == "y"
					filter_box.each do |item|
						if item.class == Gtk::Entry
							item.grab_focus	
							break
						end
					end
				end

				if key == "t"
					Actions.edit 	@db ,@store, @tree, @settings.s
				end

				if key == "d"
					Actions.delete 	@db ,@store, @tree, @settings.s
				end

				if key == "s"
					Actions.settings @settings, @db, @store, @tree
				end

				if key == "r"
					Actions.store_feed 	@db, @store, @tree
				end

				cursor, column 		= @tree.cursor

				if cursor
					@tree.selected_row	= cursor
					@tree.set_cursor 	cursor, nil, false
				end
			end
		end

		add 			vbox
		show_all
	end

	def make_menu
		file_open 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::OPEN
		file_import 			= Gtk::ImageMenuItem.new :label => "_Import"
		file_import.use_underline 	= true
		file_import.image 		= Gtk::Image.new \
							:pixbuf => (Actions.search_icon "insert-object")
		file_exit 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::QUIT

		edit_fetch_db	 		= Gtk::ImageMenuItem.new :label => "_Reload"
		edit_fetch_db.use_underline 	= true
		edit_fetch_db.image 		= Gtk::Image.new \
							:pixbuf => (Actions.search_icon "reload")
		edit_fetch_fv	 		= Gtk::ImageMenuItem.new :label => "Fetch fa_vicon"
		edit_fetch_fv.use_underline 	= true
		edit_fetch_fv.image 		= Gtk::Image.new \
							:pixbuf => (Actions.search_icon \
								"starred-symbolic")
		edit_copy	 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::COPY
		edit_insert	 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::ADD
		edit_edit	 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::EDIT
		edit_delete	 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::DELETE
		edit_preferences 		= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::PREFERENCES

		help_doc 			= Gtk::ImageMenuItem.new :label => "_Doc"
		help_doc.use_underline 		= true
		help_about 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::ABOUT


		file_open.signal_connect "activate" do
			if (ret = Actions.open @store, @tree, @settings, self)
				@db = ret
			end
		end

		file_import.signal_connect "activate" do
			Actions.import 		@db, self
			Actions.store_feed 	@db, @store, @tree
		end

		file_exit.signal_connect "activate" do
			Gtk.main_quit
		end

		edit_fetch_db.signal_connect "activate" do
			Actions.store_feed 	@db, @store, @tree
		end

		edit_fetch_fv.signal_connect "activate" do
			Actions.download_favicon @store, @tree, @settings.s
		end

		edit_copy.signal_connect "activate" do
			Actions.clipboard 	@store, @tree, @settings['xclip']
		end

		edit_insert.signal_connect "activate" do
			Actions.insert 		@db, @store, @tree, @settings.s
		end

		edit_delete.signal_connect "activate" do
			Actions.delete 		@db, @store, @tree, @settings.s
		end

		edit_edit.signal_connect "activate" do
			Actions.edit 		@db, @store, @tree, @settings.s
		end

		edit_preferences.signal_connect "activate" do
			Actions.settings 	@settings, @db, @store, @tree
		end

		help_about.signal_connect "activate" do
			about 			= Gtk::AboutDialog.new
			about.name 		= "poor man's bookmark"
			about.program_name 	= "pmb"
			about.version  		= "0.1"
			about.license		= "GNU GPL 2.0"
			about.website 		= "https://github.com/neoncortex/poor-man-s-bookmark"
			
			about.run
			about.destroy
		end

		menu_items = Hash[ \
			"file_open" 		=> file_open \
			,"file_import" 		=> file_import \
			,"file_exit" 		=> file_exit \
			,"edit_copy" 		=> edit_copy \
			,"edit_insert" 		=> edit_insert \
			,"edit_edit" 		=> edit_edit \
			,"edit_delete" 		=> edit_delete \
			,"edit_fetch_db" 	=> edit_fetch_db \
			,"edit_fetch_fv" 	=> edit_fetch_fv \
			,"edit_preferences" 	=> edit_preferences \
			,"help_doc" 		=> help_doc \
			,"help_about" 		=> help_about]
	end

	def make_menubar items
		file_item 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::FILE
		file_item.image 		= nil
		file_menu 			= Gtk::Menu.new
		file_item.set_submenu 		file_menu
		file_menu.append 		items['file_open']
		file_menu.append 		items['file_import']
		file_menu.append 		items['file_exit']

		edit_item 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::EDIT
		edit_item.image 		= nil
		edit_menu 			= Gtk::Menu.new
		edit_item.set_submenu 		edit_menu
		edit_menu.append 		items['edit_copy']
		edit_menu.append 		items['edit_insert']
		edit_menu.append 		items['edit_edit']
		edit_menu.append 		items['edit_delete']
		edit_menu.append 		items['edit_fetch_db']
		edit_menu.append 		items['edit_fetch_fv']
		edit_menu.append 		items['edit_preferences']

		help_item 			= Gtk::ImageMenuItem.new :stock_id => Gtk::Stock::HELP
		help_item.image 		= nil
		help_menu 			= Gtk::Menu.new 
		help_item.set_submenu 		help_menu
		help_menu.append		items['help_doc']
		help_menu.append		items['help_about']

		menu_bar = Gtk::MenuBar.new
		menu_bar.append 		file_item
		menu_bar.append 		edit_item
		menu_bar
	end

	def make_tree_menu items
		menu 			= Gtk::Menu.new
		menu.append 		items['edit_copy']
		menu.append 		items['edit_insert']
		menu.append 		items['edit_edit']
		menu.append 		items['edit_delete']
		menu.append 		items['edit_fetch_db']
		menu.append 		items['edit_fetch_fv']
		menu.append 		items['edit_preferences']
		menu.append 		Gtk::SeparatorMenuItem.new
		menu.append 		items['file_open']
		menu.append 		items['file_import']
		menu.append 		items['file_exit']
		menu.show_all
		menu
	end

	def make_tree 
		tree			= Tree.new @store
		tree.load_settings	@settings.s
		tree.search_column 	= @settings.s['search_column'].to_i
		tree.selection.mode	= :multiple

		tree.insert_column 	0, "tag" \
						,tree.render_tag, {:text => 4}

		tree.insert_column 	1, "id" \
						,tree.render_id, {:text => 0}

		tree.insert_column 	2, "ico" \
						,Gtk::CellRendererPixbuf.new, {:pixbuf => 2}

		tree.insert_column 	3, "name" \
						,tree.render_name, {:text => 1}

		tree.insert_column 	4, "url" \
						,tree.render_url, {:text => 3}

		tree.insert_column 	5, "comment" \
						,tree.render_comment, {:text => 5}

		tree.signal_connect "row-activated" do |tree, path, col|
			if tree.row_expanded? path
				tree.collapse_row path
			else
				tree.expand_row path, nil
			end

			Actions.clipboard @store, @tree, @settings.s['xclip']
		end

		menu		= make_tree_menu make_menu

		tree.signal_connect "button-press-event" do |tree, e|
			if e.kind_of? Gdk::EventButton and e.button == 3
				menu.popup nil, nil, e.button, e.time
			end
		end

		tree.signal_connect "popup_menu" do
			menu.popup nil, nil, 0, Gdk::Event::CURRENT_TIME
		end

		tree
	end

	def make_filter_box
		filter_label 			= Gtk::Label.new " Filter "
		filter_entry 			= Gtk::Entry.new
		filter_button 			= Gtk::Button.new :stock_id => Gtk::Stock::APPLY

		if (icon = Actions.search_icon "edit-find-symbolic")
			filter_entry.primary_icon_pixbuf = icon
			filter_entry.primary_icon_activatable = false
		end

		filter_button.signal_connect "clicked" do
			@store.filter 		= filter_entry.text
			Actions.store_feed 	@db, @store, @tree
		end

		filter_entry.signal_connect "activate" do
			@store.filter 		= filter_entry.text
			Actions.store_feed 	@db, @store, @tree
		end

		filter_box 			= Gtk::Box.new :horizontal, 2
		filter_box.pack_start 		filter_label \
							,:expand 	=> false \
							,:fill 		=> false

		filter_box.pack_start 		filter_entry \
							,:expand 	=> true \
							,:fill 		=> true 

		filter_box.pack_start 		filter_button \
							,:expand 	=> false \
							,:fill 		=> false

		filter_box
	end
end

Gtk.init
Gtk_Ui.new
Gtk.main

