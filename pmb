#!/usr/bin/env ruby

require 'gtk3'
require 'sqlite3'

class Db
	def initialize path
		begin
			@db = SQLite3::Database.open path
		rescue
			puts 		"can't open database"
			exit
		end

		@db.execute 	"CREATE TABLE IF NOT EXISTS bookmark" \
					"(id INTEGER PRIMARY KEY" \
					",name text" \
					",url text" \
					",comment text" \
					",tag tex)"
	end

	def insert data
		stm 		= @db.prepare "INSERT INTO bookmark " \
					"(name, url, comment, tag) VALUES(?,?,?,?)"
	
		stm.bind_param 	1, data[0]
		stm.bind_param 	2, data[1]
		stm.bind_param 	3, data[2]
		stm.bind_param 	4, data[3]
		rs 		= stm.execute
	end

	def delete id
		stm 		= @db.prepare "DELETE FROM bookmark " \
					"WHERE id = ?"	

		stm.bind_param	1, id
		rs 		= stm.execute
	end

	def delete_tag tag
		stm 		= @db.prepare "DELETE FROM bookmark " \
					"WHERE tag = ?"

		stm.bind_param 	1, tag
		rs 		= stm.execute
	end

	def edit id, field, value
		if field == "name" \
		or field == "url" \
		or field == "comment" \
		or field == "tag"
			stm 		= @db.prepare "UPDATE bookmark " \
						"SET #{field} = ? WHERE id = ?"

			stm.bind_param 	1, value
			stm.bind_param 	2, id
			rs 		= stm.execute
		end
	end

	def edit_tag tag, new_tag
		stm 		= @db.prepare "UPDATE bookmark " \
					"SET tag = ? WHERE tag = ?"

		stm.bind_param 	1, new_tag
		stm.bind_param 	2, tag
		rs 		= stm.execute
	end

	def find id
		stm 		= @db.prepare "SELECT * FROM bookmark " \
					"WHERE id = ? ORDER BY tag ASC"

		stm.bind_param 	1, id
		rs		= stm.execute
	end

	def fetch filter
		if filter
			stm 	= @db.prepare "SELECT * FROM bookmark " \
					"WHERE name LIKE '%%#{filter}%%' " \
					"OR url LIKE '%%#{filter}%%' " \
					"OR comment LIKE '%%#{filter}%%' " \
					"OR tag LIKE '%%#{filter}%%' " \
					"ORDER BY tag ASC"
		else
			stm 	= @db.prepare "SELECT * from bookmark " \
					"ORDER BY tag ASC"
		end

		rs 		= stm.execute
	end
end

class Settings
	def initialize
		@s = Hash[ \
			"dir" => "#{ENV['HOME']}/.config/poor-man-s-bookmark" \
			,"config" => "config" \
			,"db_name" => "bookmarks.db" \
			,"id_fg" => "orange" \
			,"id_bg" => "" \
			,"name_fg" => "green" \
			,"name_bg" => "" \
			,"url_fg" => "blue" \
			,"url_bg" => "" \
			,"comment_fg" => "steelblue" \
			,"comment_bg"=> "" \
			,"tag_fg" => "darkblue" \
			,"tag_bg" => "" \
			,"show_expanders" => false \
			,"search_column" => 1]

		if !(File.exists? "#{@s['dir']}")
			Dir.mkdir "#{@s['dir']}"
		end

		if !(File.exists? "#{@s['dir']}/#{@s['config']}")
			save_config
		else
			load_config
		end
	end

	def save_config
		File.open("#{@s['dir']}/#{@s['config']}", "w") do |f|
			f.write "#DO NOT EDIT BY HAND"
			f.write "\n\n#database file"
			f.write "\ndb_file = #{@s['dir']}/#{@s['db_name']}"
			f.write "\n\n#show expanders? true or false"
			f.write "\nshow_expanders = #{@s['show_expanders']}"
			f.write "\n\n#search column"
			f.write "\nsearch_column = #{@s['search_column']}"
			f.write "\n\n#colors:"
			f.write "\n#id"
			f.write "\nid_fg = #{@s['id_fg']}" 
			f.write "\nid_bg = #{@s['id_bg']}" 
			f.write "\n\n#name"
			f.write "\nname_fg = #{@s['name_fg']}" 
			f.write "\nname_bg = #{@s['name_bg']}" 
			f.write "\n\n#url"
			f.write "\nurl_fg = #{@s['url_fg']}" 
			f.write "\nurl_bg = #{@s['url_bg']}" 
			f.write "\n\n#comment"
			f.write "\ncomment_fg = #{@s['comment_fg']}" 
			f.write "\ncomment_bg = #{@s['comment_bg']}" 
			f.write "\n\n#tag"
			f.write "\ntag_fg = #{@s['tag_fg']}" 
			f.write "\ntag_bg = #{@s['tag_bg']}" 
		end
	end

	def load_config
		f = File.open("#{@s['dir']}/#{@s['config']}", "r")

		while l = f.gets do
			@s.each do |i|
				# need a better regex ..
				if i[0] + ' ' == l[/(^.*?\s)/] 
					@s[i[0]] = l[/(?<==\s).*/]

					#special cases ..
					if l[/^search_column/]
						@s[i[0]] = l[/(?<==\s).*/].to_i
					end

					if l[/^show_expanders/] \
					and l[/(?<==\s).*/] == "false"
						@s[i[0]] = false
					end
				end
			end
		end
	end

	attr_accessor :s
end

class Actions
	def self.clipboard store, tree
		url 	= store.get_value \
				(tree.selection).selected, 2

		Process.detach spawn \
			"echo #{url} | xclip -i -selection 'primary']"

		Process.detach spawn \
			"echo #{url} | xclip -i -selection 'secoundary']"

		Process.detach spawn \
			"echo #{url} | xclip -i -selection 'clipboard']"
	end

	def self.store_feed db, store, tree
		store.clear
		store.feed 		(db.fetch store.filter)
		tree.expand_all
	end

	def self.insert db, store, tree
		Gtk_Insert.new 		db, store, tree
	end

	def self.edit db, store, tree
		Gtk_Edit.new 		db, store, tree
	end

	def self.delete db, store, tree
		Gtk_Delete.new 		db, store, tree
	end

	def self.error message, fatal
		Gtk_Error.new 		message, fatal
	end

	def self.settings settings, tree
		Gtk_Settings.new settings, tree
	end
end

class Store < Gtk::TreeStore
	attr_accessor :filter

	def feed result
		last 			= nil
		number_of_items 	= 0

		for i in result do
			if !last or i[4] != last
				iter = insert nil, number_of_items \
					+= 1 \
					,[" " \
					," " \
					," " \
					,"#{i[4]}"]
			end

			insert iter, number_of_items += 1 \
				,["#{i[0]}" \
				,"#{i[1]}" \
				,"#{i[2]}" \
				,"" \
				,"#{i[3]}"]

			last 		= i[4]
		end
	end
end

	
class Tree < Gtk::TreeView
	def initialize store
		super store

		@render_id 		= Gtk::CellRendererText.new
		@render_name		= Gtk::CellRendererText.new
		@render_url 		= Gtk::CellRendererText.new
		@render_comment		= Gtk::CellRendererText.new
		@render_tag 		= Gtk::CellRendererText.new
	end

	def load_colors s
		if !s['id_fg'].empty?
			@render_id.foreground 	= s['id_fg'] 
		else
			@render_id.foreground 	= nil
		end

		if !s['id_bg'].empty?
			@render_id.background 	= s['id_bg']
		else
			@render_id.background 	= nil
		end

		if !s['name_fg'].empty?
			@render_name.foreground = s['name_fg'] 
		else
			@render_name.foreground = nil
		end

		if !s['name_bg'].empty?
			@render_name.background = s['name_bg']
		else
			@render_name.background = nil
		end

		if !s['url_fg'].empty?
			@render_url.foreground 	= s['url_fg'] 
		else
			@render_url.foreground 	= nil
		end

		if !s['url_bg'].empty?
			@render_url.background 	= s['url_bg'] 
		else
			@render_url.background  = nil
		end

		if !s['comment_fg'].empty?
			@render_comment.foreground = s['comment_fg']
		else
			@render_comment.foreground = nil
		end

		if !s['comment_bg'].empty?
			@render_comment.background = s['comment_bg'] 
		else
			@render_comment.background = nil
		end

		if !s['tag_fg'].empty?
			@render_tag.foreground	= s['tag_fg'] 
		else
			@render_tag.foreground	= nil
		end

		if !s['tag_bg'].empty?
			@render_tag.background 	= s['tag_bg'] 
		else
			@render_tag.background 	= nil
		end
	end

	attr_accessor \
		:render_id \
		,:render_name \
		,:render_url \
		,:render_comment \
		,:render_tag
end

class Grid < Gtk::Grid
	def initialize
		super
		set_property 		"row-homogeneous"	,true
		set_property 		"column-homogeneous"	,true
	end
end

class Gtk_Window < Gtk::Window
	def initialize 
		super
		set_wmclass 		"Poor man's bookmark"	,"Pmb"
		set_title 		"Poor man's bookmark"
		set_type_hint 		:dialog


		signal_connect "destroy" do
			destroy
		end
	end
end

class Gtk_Error < Gtk_Window
	def initialize message, fatal
		super()
		set_title 		title + " - Error"

		error_label 		= Gtk::Label.new 
		error_label.set_markup	"<span foreground='red' " \
						"font-weight='heavy' " \
						"size='large'>" \
						"Error \n" \
						"</span>"

		error 				= Gtk::Label.new message
		close_button 			= Gtk::Button.new :label => "_Close"
		close_button.use_underline 	= true

		close_button.signal_connect "clicked" do
			if fatal
				Gtk.main_quit
			else
				destroy
			end
		end

		grid 				= Grid.new

						#e   #t   #l    #a
		grid.attach error_label, 	0,   0,   20,   1
		grid.attach error, 		0,   1,   20,   1
		grid.attach close_button, 	0,   2,   20,   1

		vbox 				= Gtk::Box.new :vertical, 2
		vbox.pack_start 		grid \
							,:expand => false \
							,:fill => false \
							,:padding => 0 \

		add 				vbox
		show_all
	end
end

class Gtk_Insert < Gtk_Window
	def initialize db, store, tree
		super()
		set_title 			title + " - Insert"

		name_entry 			= Gtk::Entry.new
		url_entry 			= Gtk::Entry.new
		comment_entry 			= Gtk::Entry.new
		tag_entry 			= Gtk::Entry.new
		insert_button 			= Gtk::Button.new :label => "_Insert"
		cancel_button 			= Gtk::Button.new :label => "_Cancel"
		insert_button.use_underline 	= true
		cancel_button.use_underline 	= true


		if tree.selection.selected
			tag_entry.set_text store.get_value \
				(tree.selection).selected, 3
		end

		insert_button.signal_connect "clicked" do
			if (name_entry.text).size > 0 and (url_entry.text).size > 0
				name		= name_entry.text
				url 		= url_entry.text

				if (comment_entry.text).size == 0
					comment 	= "none"
				else
					comment 	= comment_entry.text
				end

				if (tag_entry.text).size == 0
					tag 		= "none"
				else
					tag 		= tag_entry.text
				end

				db.insert 		[name, url, comment, tag]
				Actions.store_feed 	db, store, tree
				destroy
			else
				Actions.error "Need at least name and url", false
			end
		end

		cancel_button.signal_connect "clicked" do
			destroy
		end

		grid 			= Grid.new

								#e   #t   #l    #a
		grid.attach (Gtk::Label.new "Name"), 		0,   0,   20,   1
		grid.attach name_entry, 			20,  0,   20,   1
		grid.attach (Gtk::Label.new "Url"), 		0,   1,   20,   1
		grid.attach url_entry,				20,  1,   20,   1
		grid.attach (Gtk::Label.new "Comment"),		0,   2,   20,   1
		grid.attach comment_entry,			20,  2,   20,   1
		grid.attach (Gtk::Label.new "Tag"), 		0,   3,   20,   1
		grid.attach tag_entry,				20,  3,   20,   1
		grid.attach insert_button,			0,   4,   20,   1
		grid.attach cancel_button,			20,  4,   20,   1

		vbox 			= Gtk::Box.new :vertical, 2
		vbox.pack_start 	grid \
						,:expand 	=> false \
						,:fill 		=> false \
						,:padding 	=> 0 \

		add 			vbox
		show_all
	end
end

class Gtk_Edit < Gtk_Window
	def initialize db, store, tree
		super()
		set_title 			title + " - Edit"

		name_entry 			= Gtk::Entry.new
		url_entry 			= Gtk::Entry.new
		comment_entry 			= Gtk::Entry.new
		tag_entry 			= Gtk::Entry.new
		edit_button 			= Gtk::Button.new :label => "_Edit"
		cancel_button 			= Gtk::Button.new :label => "_Cancel"
		edit_button.use_underline 	= true
		cancel_button.use_underline 	= true

		grid 			= Grid.new

		rs 			= db.find (store.get_value \
						(tree.selection).selected, 0)

		if n = rs.next
			name_entry.set_text 	n[1]
			url_entry.set_text 	n[2]
			comment_entry.set_text 	n[3]
			tag_entry.set_text 	n[4]

			edit_button.signal_connect "clicked" do
				if n[1] != name_entry.text 
					db.edit n[0], "name", name_entry.text
				end

				if n[2] != url_entry.text 
					db.edit n[0], "url", url_entry.text
				end

				if n[3] != comment_entry.text 
					db.edit n[0], "comment", comment_entry.text
				end

				if n[4] != tag_entry.text
					db.edit n[0], "tag", tag_entry.text
				end

				Actions.store_feed 	db, store, tree
				destroy
			end
								#e   #t   #l    #a
			grid.attach (Gtk::Label.new "Name"),	0,   0,   20,   1
			grid.attach name_entry, 		20,  0,   20,   1
			grid.attach (Gtk::Label.new "Url"), 	0,   1,   20,   1
			grid.attach url_entry,			20,  1,   20,   1
			grid.attach (Gtk::Label.new "Comment"),	0,   2,   20,   1
			grid.attach comment_entry,		20,  2,   20,   1
			grid.attach (Gtk::Label.new "Tag"), 	0,   3,   20,   1
			grid.attach tag_entry,			20,  3,   20,   1
			grid.attach edit_button,		0,   4,   20,   1
			grid.attach cancel_button,		20,  4,   20,   1
		else
			set_title 	"Poor man's bookmark - Edit tag"
			old_tag 	= store.get_value \
						(tree.selection).selected, 3

			tag_entry.set_text old_tag
			
			edit_button.signal_connect "clicked" do
				db.edit_tag 		old_tag, tag_entry.text
				Actions.store_feed 	db, store, tree
				destroy
			end
								#e   #t   #l    #a
			grid.attach (Gtk::Label.new "Tag"),	0,   0,   20,   1
			grid.attach tag_entry, 			20,  0,   20,   1
			grid.attach edit_button,		0,   1,   20,   1
			grid.attach cancel_button,		20,  1,   20,   1
		end

		cancel_button.signal_connect "clicked" do
			destroy
		end

		vbox 			= Gtk::Box.new :vertical, 2
		vbox.pack_start 	grid \
						,:expand 	=> false \
						,:fill 		=> false \
						,:padding 	=> 0 \

		add 			vbox
		show_all
	end
end

class Gtk_Delete < Gtk_Window
	def initialize db, store, tree
		super()
		set_title 			title + " - Delete?"

		id 		= store.get_value \
					(tree.selection).selected, 0

		name 		= store.get_value \
					(tree.selection).selected, 1

		url 		= store.get_value \
					(tree.selection).selected, 2

		comment 	= store.get_value \
					(tree.selection).selected, 4

		tag 		= store.get_value \
					(tree.selection).selected, 3

		name_entry 			= Gtk::Entry.new
		name_entry.set_text 		name
		name_entry.set_editable 	false

		url_entry 			= Gtk::Entry.new
		url_entry.set_text 		url
		url_entry.set_editable 		false

		comment_entry 			= Gtk::Entry.new
		comment_entry.set_text 		comment
		comment_entry.set_editable 	false

		tag_entry 			= Gtk::Entry.new
		tag_entry.set_text 		tag
		tag_entry.set_editable 		false

		delete_button 			= Gtk::Button.new :label => "_Delete"
		delete_button.use_underline 	= true

		cancel_button 			= Gtk::Button.new :label => "_Cancel"
		cancel_button.use_underline 	= true

		delete_button.signal_connect "clicked" do
			if id.size < 2
				db.delete_tag 		tag
			else
				db.delete 		id
			end

			Actions.store_feed 	db, store, tree
			destroy
		end

		cancel_button.signal_connect "clicked" do
			destroy
		end

		grid 			= Grid.new

								#e   #t   #l    #a
		grid.attach (Gtk::Label.new "Name"), 		0,   0,   20,   1
		grid.attach name_entry, 			20,  0,   20,   1
		grid.attach (Gtk::Label.new "Url"), 		0,   1,   20,   1
		grid.attach url_entry,				20,  1,   20,   1
		grid.attach (Gtk::Label.new "Comment"),		0,   2,   20,   1
		grid.attach comment_entry,			20,  2,   20,   1
		grid.attach (Gtk::Label.new "Tag"), 		0,   3,   20,   1
		grid.attach tag_entry,				20,  3,   20,   1
		grid.attach delete_button,			0,   4,   20,   1
		grid.attach cancel_button,			20,  4,   20,   1

		vbox 			= Gtk::Box.new :vertical, 2
		vbox.pack_start 	grid \
						,:expand 	=> false \
						,:fill 		=> false \
						,:padding 	=> 0 \

		cancel_button.grab_focus
		add 			vbox
		show_all
	end
end

class Gtk_Settings < Gtk_Window
	def initialize settings, tree
		super()
		set_title 		title + " - Options"

		id_fg 			= Gtk::Entry.new
		id_bg 			= Gtk::Entry.new
		name_fg 		= Gtk::Entry.new
		name_bg 		= Gtk::Entry.new
		url_fg			= Gtk::Entry.new
		url_bg			= Gtk::Entry.new
		comment_fg 		= Gtk::Entry.new
		comment_bg 		= Gtk::Entry.new
		tag_fg 			= Gtk::Entry.new
		tag_bg 			= Gtk::Entry.new

		s = settings.s

		id_fg.text 		= s['id_fg']      
		id_bg.text 		= s['id_bg']      
		name_fg.text 		= s['name_fg']  
		name_bg.text 		= s['name_bg']
		url_fg.text 		= s['url_fg']    
		url_bg.text 		= s['url_bg']     
		comment_fg.text 	= s['comment_fg'] 
		comment_bg.text 	= s['comment_bg']
		tag_fg.text 		= s['tag_fg'] 
		tag_bg.text 		= s['tag_bg']

		apply_button 			= Gtk::Button.new :label => "_Apply"
		apply_button.use_underline 	= true

		apply_button.signal_connect "clicked" do
			s['id_fg'] 		= id_fg.text 
			s['id_bg']  		= id_bg.text 
			s['name_fg']    	= name_fg.text 
			s['name_bg']    	= name_bg.text 
			s['url_fg']     	= url_fg.text 
			s['url_bg']     	= url_bg.text 
			s['comment_fg'] 	= comment_fg.text 
			s['comment_bg'] 	= comment_bg.text 
			s['tag_fg']     	= tag_fg.text 
			s['tag_bg']     	= tag_bg.text 

			settings.save_config
			tree.load_colors s
			destroy
		end

		grid 				= Grid.new
								#e   #t   #l    #a
		grid.attach (Gtk::Label.new "Column"),   	0,   0,   20,   1
		grid.attach (Gtk::Label.new "Foreground"),     	20,  0,   20,   1
		grid.attach (Gtk::Label.new "Background"),     	40,  0,   20,   1
		grid.attach (Gtk::Label.new "id"),		0,   1,   20,   1
		grid.attach id_fg,				20,  1,   20,   1
		grid.attach id_bg,				40,  1,   20,   1
		grid.attach (Gtk::Label.new "name"),		0,   2,   20,   1
		grid.attach name_fg,				20,  2,   20,   1
		grid.attach name_bg,				40,  2,   20,   1
		grid.attach (Gtk::Label.new "Url"), 		0,   3,   20,   1
		grid.attach url_fg,				20,  3,   20,   1
		grid.attach url_bg,				40,  3,   20,   1
		grid.attach (Gtk::Label.new "Comment"),		0,   4,   20,   1
		grid.attach comment_fg,				20,  4,   20,   1
		grid.attach comment_bg,				40,  4,   20,   1
		grid.attach (Gtk::Label.new "Tag"), 		0,   5,   20,   1
		grid.attach tag_fg,				20,  5,   20,   1
		grid.attach tag_bg,				40,  5,   20,   1
		grid.attach apply_button,			20,  6,   40,   1

		color_frame 		= Gtk::Frame.new "Colors"
		color_frame.add 	grid

		vbox 			= Gtk::Box.new :vertical, 2
		vbox.pack_start 	color_frame

		add 			vbox
		show_all
	end
end

class Gtk_Ui < Gtk_Window
	def initialize 
		super
		set_default_size 	800, 600
		set_type_hint 		:normal

		signal_connect "destroy" do
			Gtk.main_quit
		end

		@settings 		= Settings.new
		@s 			= @settings.s
		@db 			= Db.new "#{@s['dir']}/#{@s['db_name']}"
		@store 			= Store.new String, String \
						,String, String, String
		@tree 			= make_tree 

		Actions.store_feed 	@db, @store, @tree

		sw 			= Gtk::ScrolledWindow.new nil, nil
		sw.border_width 	= 2
		sw.add 			@tree

		vbox 			= Gtk::Box.new :vertical, 2

		vbox.pack_start 	make_action_box \
						,:expand 	=> false \
						,:fill 		=> false

		vbox.pack_start 	sw 

		vbox.pack_start 	make_filter_box \
						,:expand 	=> false \
						,:fill 		=> false

		if @tree.model.iter_first
			@tree.set_cursor (@tree.model.iter_first).path, nil, false
			@tree.grab_focus
		end

		signal_connect "key-press-event" do |w, e|
			key = "#{Gdk::Keyval.to_name e.keyval}"

			if e.state.control_mask?
				if key == "a" 
					@tree.expand_all
				end

				if key == "x"
					@tree.collapse_all
				end

				if key == "j"
					@tree.move_cursor :display_lines, 1 
				end

				if key == "k" 
					@tree.move_cursor :display_lines, -1 
				end

				if key == "g"
					@tree.move_cursor :buffer_ends, -1
				end

				if key == "G"
					@tree.move_cursor :buffer_ends, 1
				end

				if key == "f"
					@tree.move_cursor :pages, 1
				end

				if key == "b"
					@tree.move_cursor :pages, -1
				end

				if key == "h" or key == "a"
					if sel = @tree.selection.selected
						@tree.scroll_to_cell \
							sel.path \
							,(@tree.get_column 0) \
							,false \
							,0.0 \
							,0.0
					end
				end

				if key == "l" or key == "e"
					if sel = @tree.selection.selected
						@tree.scroll_to_cell \
							sel.path \
							,(@tree.get_column 4) \
							,false \
							,0.0 \
							,0.0
					end

				end

				cursor, column 		= @tree.cursor
				@tree.set_cursor 	cursor, nil, false
			end
		end

		add 			vbox
		show_all
	end

	def make_tree_menu 
		menu_item_copy 			= Gtk::MenuItem.new "Copy"
		menu_item_copy.signal_connect "activate" do
			Actions.clipboard 	@store, @tree
		end
		
		menu_item_insert 		= Gtk::MenuItem.new "Insert"
		menu_item_insert.signal_connect "activate" do
			Actions.insert 		@db, @store, @tree
		end

		menu_item_delete 		= Gtk::MenuItem.new "Delete"
		menu_item_delete.signal_connect "activate" do
			Actions.delete 		@db, @store, @tree
		end

		menu_item_edit 			= Gtk::MenuItem.new "Edit"
		menu_item_edit.signal_connect "activate" do
			Actions.edit 		@db, @store, @tree
		end

		menu_item_fetch 		= Gtk::MenuItem.new "Fetch"
		menu_item_fetch.signal_connect "activate" do
			Actions.store_feed 	@db, @store, @tree
		end

		menu 			= Gtk::Menu.new
		menu.append 		menu_item_copy
		menu.append 		menu_item_insert
		menu.append 		menu_item_edit
		menu.append 		menu_item_delete
		menu.show_all
		menu
	end

	def make_tree 
		tree			= Tree.new @store

		tree.render_id.foreground 	= @s['id_fg'] \
			if !@s['id_fg'].empty? 	

		tree.render_id.background 	= @s['id_bg'] \
			if !@s['id_bg'].empty? 

		tree.render_name.foreground 	= @s['name_fg'] \
			if !@s['name_fg'].empty?

		tree.render_name.background 	= @s['name_bg'] \
			if !@s['name_bg'].empty?

		tree.render_url.foreground 	= @s['url_fg'] \
			if !@s['url_fg'].empty?

		tree.render_url.background 	= @s['url_bg'] \
			if !@s['url_bg'].empty?

		tree.render_comment.foreground 	= @s['comment_fg'] \
			if !@s['comment_fg'].empty?

		tree.render_comment.background 	= @s['comment_bg'] \
			if !@s['comment_bg'].empty?

		tree.render_tag.foreground 	= @s['tag_fg'] \
			if !@s['tag_fg'].empty?

		tree.render_tag.background 	= @s['tag_bg'] \
			if !@s['tag_bg'].empty?

		tree.insert_column 	0, "tag" \
						,tree.render_tag, {:text => 3}

		tree.insert_column 	1, "id" \
						,tree.render_id, {:text => 0}

		tree.insert_column 	2, "name" \
						,tree.render_name,{:text => 1}

		tree.insert_column 	3, "url" \
						,tree.render_url, {:text => 2}

		tree.insert_column 	4, "comment" \
						,tree.render_comment, {:text => 4}

		tree.search_column 	= @s['search_column']
		tree.show_expanders 	= @s['show_expanders']

		tree.signal_connect "row-activated" do |tree, path, col|
			if path.depth <= 1
				if tree.row_expanded? path
					tree.collapse_row path
				else
					tree.expand_row path, nil
				end
			else
				Actions.clipboard @store, @tree
			end
		end

		menu			= make_tree_menu

		tree.signal_connect "button-press-event" do |tree, e|
			if e.kind_of? Gdk::EventButton and e.button == 3
				menu.popup nil, nil, e.button, e.time
			end
		end

		tree.signal_connect "popup_menu" do
			menu.popup nil, nil, 0, Gdk::Event::CURRENT_TIME
		end

		tree
	end

	def make_action_box 
		insert_button 			= Gtk::Button.new :label => "_Insert"
		insert_button.use_underline 	= true
		insert_button.signal_connect "clicked" do
			Actions.insert 		@db, @store, @tree
		end

		edit_button 			= Gtk::Button.new :label => "_Edit"
		edit_button.use_underline 	= true
		edit_button.signal_connect "clicked" do
			Actions.edit 		@db, @store, @tree
		end

		delete_button 			= Gtk::Button.new :label => "_Delete"
		delete_button.use_underline 	= true
		delete_button.signal_connect "clicked" do
			Actions.delete 		@db, @store, @tree
		end

		fetch_button 			= Gtk::Button.new :label => "_Fetch"
		fetch_button.use_underline 	= true
		fetch_button.signal_connect "clicked" do
			Actions.store_feed 	@db, @store, @tree
		end

		settings_button 		= Gtk::Button.new \
							:label => "_Settings"
		settings_button.use_underline 	= true
		settings_button.signal_connect "clicked" do
			Actions.settings 	@settings, @tree
		end

		action_box 			= Gtk::Box.new :horizontal, 2
		action_box.pack_start 		insert_button
		action_box.pack_start 		edit_button 
		action_box.pack_start 		delete_button 
		action_box.pack_start 		fetch_button 
		action_box.pack_start 		settings_button 
		action_box
	end

	def make_filter_box
		filter_label 			= Gtk::Label.new " Key "
		filter_entry 			= Gtk::Entry.new
		filter_button 			= Gtk::Button.new :label => "Fi_lter"
		filter_button.use_underline 	= true

		filter_button.signal_connect "clicked" do
			@store.filter 		= filter_entry.text
			Actions.store_feed 	@db, @store, @tree
		end

		filter_box 			= Gtk::Box.new :horizontal, 2
		filter_box.pack_start 		filter_label \
							,:expand 	=> false \
							,:fill 		=> false

		filter_box.pack_start 		filter_entry \
							,:expand 	=> true \
							,:fill 		=> true 

		filter_box.pack_start 		filter_button \
							,:expand 	=> false \
							,:fill 		=> false

		filter_box
	end
end

Gtk.init
Gtk_Ui.new
Gtk.main

